{"version":3,"file":"annotorious-selector-pack.min.js","mappings":"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","sources":["webpack://Annotorious.SelectorPack/webpack/universalModuleDefinition","webpack://Annotorious.SelectorPack/../annotorious/node_modules/tiny-emitter/index.js","webpack://Annotorious.SelectorPack/../recogito-client-core/node_modules/fast-deep-equal/index.js","webpack://Annotorious.SelectorPack/webpack/bootstrap","webpack://Annotorious.SelectorPack/webpack/runtime/compat get default export","webpack://Annotorious.SelectorPack/webpack/runtime/define property getters","webpack://Annotorious.SelectorPack/webpack/runtime/hasOwnProperty shorthand","webpack://Annotorious.SelectorPack/../recogito-client-core/node_modules/uuid/dist/esm-browser/rng.js","webpack://Annotorious.SelectorPack/../annotorious/src/util/Touch.js","webpack://Annotorious.SelectorPack/../annotorious/src/util/SVG.js","webpack://Annotorious.SelectorPack/../recogito-client-core/node_modules/uuid/dist/esm-browser/regex.js","webpack://Annotorious.SelectorPack/../recogito-client-core/node_modules/uuid/dist/esm-browser/validate.js","webpack://Annotorious.SelectorPack/../recogito-client-core/node_modules/uuid/dist/esm-browser/stringify.js","webpack://Annotorious.SelectorPack/../recogito-client-core/node_modules/uuid/dist/esm-browser/v4.js","webpack://Annotorious.SelectorPack/../recogito-client-core/src/WebAnnotation.js","webpack://Annotorious.SelectorPack/../recogito-client-core/src/Selection.js","webpack://Annotorious.SelectorPack/../annotorious/src/tools/Tool.js","webpack://Annotorious.SelectorPack/../annotorious/src/tools/EditableShape.js","webpack://Annotorious.SelectorPack/../annotorious/src/selectors/RectFragment.js","webpack://Annotorious.SelectorPack/./src/point/Point.js","webpack://Annotorious.SelectorPack/./src/point/EditablePoint.js","webpack://Annotorious.SelectorPack/./src/point/PointTool.js","webpack://Annotorious.SelectorPack/../annotorious/src/selectors/EmbeddedSVG.js","webpack://Annotorious.SelectorPack/./src/circle/Circle.js","webpack://Annotorious.SelectorPack/./src/circle/CircleMask.js","webpack://Annotorious.SelectorPack/./src/circle/RubberbandCircle.js","webpack://Annotorious.SelectorPack/../annotorious/src/util/Formatting.js","webpack://Annotorious.SelectorPack/./src/circle/EditableCircle.js","webpack://Annotorious.SelectorPack/./src/circle/RubberbandCircleTool.js","webpack://Annotorious.SelectorPack/./src/ellipse/Ellipse.js","webpack://Annotorious.SelectorPack/./src/ellipse/EllipseMask.js","webpack://Annotorious.SelectorPack/./src/ellipse/RubberbandEllipse.js","webpack://Annotorious.SelectorPack/./src/ellipse/EditableEllipse.js","webpack://Annotorious.SelectorPack/./src/ellipse/RubberbandEllipseTool.js","webpack://Annotorious.SelectorPack/./src/freehand/RubberbandFreehand.js","webpack://Annotorious.SelectorPack/./src/freehand/EditableFreehand.js","webpack://Annotorious.SelectorPack/./src/freehand/RubberbandFreehandTool.js","webpack://Annotorious.SelectorPack/./src/multipolygon/RubberbandMultipolygon.js","webpack://Annotorious.SelectorPack/./src/multipolygon/EditableMultipolygon.js","webpack://Annotorious.SelectorPack/./src/multipolygon/RubberbandMultipolygonTool.js","webpack://Annotorious.SelectorPack/./src/betterMultipolygon/RubberbandBetterMultipolygon.js","webpack://Annotorious.SelectorPack/../annotorious/src/util/Geom2D.js","webpack://Annotorious.SelectorPack/./src/betterMultipolygon/EditableBetterMultipolygon.js","webpack://Annotorious.SelectorPack/./src/betterMultipolygon/RubberbandBetterMultipolygonTool.js","webpack://Annotorious.SelectorPack/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Annotorious\"] = factory();\n\telse\n\t\troot[\"Annotorious\"] = root[\"Annotorious\"] || {}, root[\"Annotorious\"][\"SelectorPack\"] = factory();\n})(self, function() {\nreturn ","function E () {\n  // Keep this empty so it's easier to inherit from\n  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n}\n\nE.prototype = {\n  on: function (name, callback, ctx) {\n    var e = this.e || (this.e = {});\n\n    (e[name] || (e[name] = [])).push({\n      fn: callback,\n      ctx: ctx\n    });\n\n    return this;\n  },\n\n  once: function (name, callback, ctx) {\n    var self = this;\n    function listener () {\n      self.off(name, listener);\n      callback.apply(ctx, arguments);\n    };\n\n    listener._ = callback\n    return this.on(name, listener, ctx);\n  },\n\n  emit: function (name) {\n    var data = [].slice.call(arguments, 1);\n    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n    var i = 0;\n    var len = evtArr.length;\n\n    for (i; i < len; i++) {\n      evtArr[i].fn.apply(evtArr[i].ctx, data);\n    }\n\n    return this;\n  },\n\n  off: function (name, callback) {\n    var e = this.e || (this.e = {});\n    var evts = e[name];\n    var liveEvents = [];\n\n    if (evts && callback) {\n      for (var i = 0, len = evts.length; i < len; i++) {\n        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n          liveEvents.push(evts[i]);\n      }\n    }\n\n    // Remove event from queue to prevent memory leak\n    // Suggested by https://github.com/lazd\n    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n    (liveEvents.length)\n      ? e[name] = liveEvents\n      : delete e[name];\n\n    return this;\n  }\n};\n\nmodule.exports = E;\nmodule.exports.TinyEmitter = E;\n","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","const SIM_EVENTS = {\n  touchstart: 'mousedown',\n  touchmove: 'mousemove',\n  touchend: 'mouseup'\n}\n\nexport const isTouchDevice = () =>\n  'ontouchstart' in window ||\n    navigator.maxTouchPoints > 0 ||\n      navigator.msMaxTouchPoints > 0;\n\nexport const enableTouchTranslation = el => {\n\n  let pressAndHoldTrigger = null;\n\n  const simulateEvent = (type, e) => new MouseEvent(type, {\n    screenX: e.screenX,\n    screenY: e.screenY,\n    clientX: e.clientX,\n    clientY: e.clientY,\n    pageX: e.pageX,\n    pageY: e.pageY,\n    bubbles: true\n  });\n\n  const touchHandler = evt => {\n    const touch = evt.changedTouches[0];\n    const simulatedEvent = simulateEvent(SIM_EVENTS[evt.type], touch);\n\n    touch.target.dispatchEvent(simulatedEvent);\n    evt.preventDefault();\n\n    if (evt.type === 'touchstart' || evt.type === 'touchmove') {\n      pressAndHoldTrigger && clearTimeout(pressAndHoldTrigger);\n\n      pressAndHoldTrigger = setTimeout(() => {\n        const simulatedEvent = simulateEvent('dblclick', touch);\n        touch.target.dispatchEvent(simulatedEvent);\n      }, 800);\n    }\n\n    if (evt.type === 'touchend')\n      pressAndHoldTrigger && clearTimeout(pressAndHoldTrigger);\n  }\n\n  el.addEventListener('touchstart', touchHandler, true);\n  el.addEventListener('touchmove', touchHandler, true);\n  el.addEventListener('touchend', touchHandler, true);\n  el.addEventListener('touchcancel', touchHandler, true);\n\n}","export const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n\nconst getClassNames = el => {\n  const attr = el.getAttribute('class');\n  return attr ? new Set(attr.split(' ')) : new Set();\n}\n\n// IE11 doesn't support adding/removing classes to SVG elements except \n// via .setAttribute\nexport const addClass = (el, className) => {\n  const classNames = getClassNames(el);\n  classNames.add(className);\n  el.setAttribute('class', Array.from(classNames).join(' '));\n}\n\nexport const removeClass = (el, className) => {\n  const classNames = getClassNames(el);\n  classNames.delete(className);\n\n  if (classNames.size === 0)\n    el.removeAttribute('class');\n  else\n    el.setAttribute('class', Array.from(classNames).join(' '));\n}\n\nexport const hasClass = (el, className) =>\n  getClassNames(el).has(className);","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import rng from './rng.js';\nimport stringify from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return stringify(rnds);\n}\n\nexport default v4;","import { v4 as uuid } from 'uuid';\nimport equals from 'fast-deep-equal';\n\nexport default class WebAnnotation {\n\n  constructor(annotation, opts) {\n    this.underlying = annotation;\n    this.opts = opts;\n  }\n\n  /** For convenience - creates an empty web annotation **/\n  static create = args => {\n    const stub = {\n      '@context': 'http://www.w3.org/ns/anno.jsonld',\n      'type': 'Annotation',\n      'id': `#${uuid()}`,\n      'body': []\n    };\n\n    return new WebAnnotation({ ...stub, ...args });\n  }\n\n  /** Creates a copy of this annotation **/\n  clone = (opt_props, opt_opts) => {\n    return new WebAnnotation({ ...this.underlying, ...opt_props}, { ...this.opts, ...opt_opts });\n  }\n\n  /** An equality check based on the underlying object **/\n  isEqual(other) {\n    if (other?.type !== 'Annotation') {\n      return false;\n    } else if (this.underlying === other.underlying) {\n      return true;\n    } else if (!this.underlying.id || !other.underlying.id) {\n      return false;\n    } else {\n      return equals(this.underlying, other.underlying);\n    }\n  }\n  getStyle(){\n    return this.opts?.style;\n  }\n  get readOnly() {\n    return this.opts?.readOnly;\n  }\n\n  /*************************************/ \n  /* Getters to forward properties of  */\n  /* the underlying annotation         */\n  /*************************************/\n\n  get id() {\n    return this.underlying.id; \n  }\n\n  get type() {\n    return this.underlying.type;\n  }\n\n  get motivation() {\n    return this.underlying.motivation;\n  }\n\n  get body() {\n    return this.underlying.body;\n  }\n\n  get target() {\n    return this.underlying.target;\n  }\n\n  /** Same as .body, but guaranteed to return an array **/\n  get bodies() {\n    return (Array.isArray(this.underlying.body)) ?\n      this.underlying.body : [ this.underlying.body ];\n  }\n\n  setState(state){\n    for (const [key, value] of Object.entries(state)){\n      this.opts[key] = value;\n    }\n  }\n\n  /** Only bodies are meant to be mutated by the application **/\n  set bodies(bodies) {\n    this.underlying.body = bodies;\n  }\n\n  /** Same as .target, but guaranteed to return an array **/\n  get targets() {\n    return (Array.isArray(this.underlying.target)) ?\n      this.underlying.target : [ this.underlying.target ];\n  }\n  \n  /*****************************************/ \n  /* Various access helpers and shorthands */\n  /*****************************************/\n\n  /** Selector of the given type **/\n  selector = type => {\n    const { target } = this.underlying;\n\n    if (target.selector) {\n      // Normalize to array\n      const selectors = Array.isArray(target.selector) ?\n        target.selector : [ target.selector ];\n\n      return selectors.find(s => s.type === type);\n    }\n  }\n\n  /** Shorthand for the 'exact' field of the TextQuoteSelector **/\n  get quote() {\n    return this.selector('TextQuoteSelector').exact;\n  }\n\n  /** Shorthand for the 'start' field of the TextPositionSelector **/\n  get start() {\n    return this.selector('TextPositionSelector').start;\n  }\n\n  /** Shorthand for the 'end' field of the TextPositionSelector **/\n  get end() {\n    return this.selector('TextPositionSelector').end;\n  }\n  \n}\n","import WebAnnotation from './WebAnnotation';\nimport { v4 as uuid } from 'uuid';\nimport equals from 'fast-deep-equal';\n\n/**\n * An \"annotation in draft mode\". Really the same\n * data structure, but as a separate class so we can\n * tell things apart properly.\n */\nexport default class Selection {\n\n  constructor(target, body) {\n    this.underlying = {\n      type: 'Selection',\n      body: body || [],\n      target\n    }\n  }\n\n  /** Creates a copy of this selection **/\n  clone = opt_props => {\n    // Deep-clone\n    const cloned = new Selection();\n    cloned.underlying = JSON.parse(JSON.stringify(this.underlying));  \n\n    if (opt_props)\n      cloned.underlying = { ...cloned.underlying, ...opt_props };\n\n    return cloned;\n  }\n\n  get type() {\n    return this.underlying.type;\n  }\n\n  get body() {\n    return this.underlying.body;\n  }\n\n  get target() {\n    return this.underlying.target;\n  }\n\n  get targets() {\n    return (Array.isArray(this.underlying.target)) ?\n      this.underlying.target : [ this.underlying.target ];\n  }\n\n  /** For consistency with WebAnnotation **/\n  isEqual(other) {\n    if (!other) {\n      return false;\n    } else {\n      return equals(this.underlying, other.underlying);\n    }\n  }\n  \n  get bodies() {\n    return (Array.isArray(this.underlying.body)) ?\n      this.underlying.body : [ this.underlying.body ];\n  }\n\n  selector = type => {\n    const { target } = this.underlying;\n\n    if (target.selector) {\n      // Normalize to array\n      const selectors = Array.isArray(target.selector) ?\n        target.selector : [ target.selector ];\n\n      return selectors.find(s => s.type === type);\n    }\n  }\n\n  /** Shorthand for the 'exact' field of the TextQuoteSelector **/\n  get quote() {\n    return this.selector('TextQuoteSelector').exact;\n  }\n\n  /*******************************************/ \n  /* Selection-specific properties & methods */\n  /*******************************************/\n\n  get isSelection() {\n    return true;\n  }\n\n  toAnnotation = () => {\n    const a = Object.assign({}, this.underlying, {\n      '@context': 'http://www.w3.org/ns/anno.jsonld',\n      'type': 'Annotation',\n      'id': `#${uuid()}`\n    });\n\n    return new WebAnnotation(a);\n  }\n\n}","import EventEmitter from 'tiny-emitter';\nimport { isTouchDevice } from '../util/Touch';\nimport { SVG_NAMESPACE } from '../util/SVG';\n\nconst IMPLEMENTATION_MISSING = \"An implementation is missing\";\n\nconst isTouch = isTouchDevice();\n\n/**\n * A commmon base class for Tools and EditableShapes\n */\nexport class ToolLike extends EventEmitter {\n\n  constructor(g, config, env) {\n    console.log(\"constructing\");\n    super();\n\n    this.svg = g.closest('svg');\n\n    this.g = g;\n    this.config = config;\n    this.env = env;\n\n    // Default image scale\n    this.scale = 1;\n\n    // Bit of a hack. If we are dealing with a 'real' image, we enable\n    // reponsive mode. OpenSeadragon handles scaling in a different way,\n    // so we don't need responsive mode.\n    const { image } = env;\n    if (image instanceof Element || image instanceof HTMLDocument)\n      this.enableResponsive();\n  }\n\n  /**\n   * Implementations MAY extend this (calling super),\n   * to destroy SVG elements, mask, etc.\n   */\n  destroy() {\n    if (this.resizeObserver)\n      this.resizeObserver.disconnect();\n\n    this.resizeObserver = null;\n  }\n\n  enableResponsive = () => {\n    if (window.ResizeObserver) {\n      this.resizeObserver = new ResizeObserver(() => {\n        const svgBounds = this.svg.getBoundingClientRect();\n        const { width, height } = this.svg.viewBox.baseVal;\n\n        this.scale = Math.max(\n          width / svgBounds.width,\n          height / svgBounds.height\n        );\n\n        if (this.onScaleChanged)\n          this.onScaleChanged(this.scale);\n      });\n\n      this.resizeObserver.observe(this.svg.parentNode);\n    }\n  }\n\n  getSVGPoint = evt => {\n    const pt = this.svg.createSVGPoint();\n\n    if (isTouch) {\n      const bbox = this.svg.getBoundingClientRect();\n\n      const x = evt.clientX - bbox.x;\n      const y = evt.clientY - bbox.y;\n\n      const { left, top } = this.svg.getBoundingClientRect();\n      pt.x = x + left;\n      pt.y = y + top;\n\n      return pt.matrixTransform(this.g.getScreenCTM().inverse());\n    } else {\n      pt.x = evt.offsetX;\n      pt.y = evt.offsetY;\n\n      return pt.matrixTransform(this.g.getCTM().inverse());\n    }\n  }\n\n  /*********************************/\n  /*  Helpers for drawing handles  */\n  /*********************************/\n\n  drawHandle = (x, y) => {\n    const containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    containerGroup.setAttribute('class', 'a9s-handle');\n\n    const group = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    const drawCircle = r => {\n      const c = document.createElementNS(SVG_NAMESPACE, 'circle');\n      c.setAttribute('cx', x);\n      c.setAttribute('cy', y);\n      c.setAttribute('r', r);\n      return c;\n    }\n\n    const radius = this.config.handleRadius || 6;\n\n    const inner = drawCircle(radius);\n    inner.setAttribute('class', 'a9s-handle-inner')\n\n    const outer = drawCircle(radius + 1);\n    outer.setAttribute('class', 'a9s-handle-outer')\n\n    group.appendChild(outer);\n    group.appendChild(inner);\n\n    containerGroup.appendChild(group);\n    return containerGroup;\n  }\n\n  setHandleXY = (handle, x, y) => {\n    const inner = handle.querySelector('.a9s-handle-inner');\n    inner.setAttribute('cx', x);\n    inner.setAttribute('cy', y);\n\n    const outer = handle.querySelector('.a9s-handle-outer');\n    outer.setAttribute('cx', x);\n    outer.setAttribute('cy', y);\n  }\n\n  getHandleXY = handle => {\n    const outer = handle.querySelector('.a9s-handle-outer');\n    return {\n      x: parseFloat(outer.getAttribute('cx')),\n      y: parseFloat(outer.getAttribute('cy'))\n    }\n  }\n\n  scaleHandle = handle => {\n    const inner = handle.querySelector('.a9s-handle-inner');\n    const outer = handle.querySelector('.a9s-handle-outer');\n\n    const radius = this.scale * (this.config.handleRadius || 6);\n    inner.setAttribute('r', radius);\n    outer.setAttribute('r', radius);\n  }\n\n}\n\n/**\n * Base class that adds some convenience stuff for tool plugins.\n */\nexport default class Tool extends ToolLike {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n\n    // We'll keep a flag set to false until\n    // the user has started moving, so we can\n    // fire the startSelection event\n    this.started = false;\n  }\n\n  attachListeners = ({ mouseMove, mouseUp, dblClick }) => {\n    // Handle SVG conversion on behalf of tool implementations\n    if (mouseMove) {\n      this.mouseMove = evt => {\n        const { x , y } = this.getSVGPoint(evt);\n\n        if (!this.started) {\n          this.emit('startSelection', { x, y });\n          this.started = true;\n        }\n\n        mouseMove(x, y, evt);\n      }\n\n      // Mouse move goes on SVG element\n      this.svg.addEventListener('mousemove', this.mouseMove);\n    }\n\n    if (mouseUp) {\n      this.mouseUp = evt => {\n        if (evt.button !== 0) return;  // left click\n        const { x , y } = this.getSVGPoint(evt);\n        mouseUp(x, y, evt);\n      }\n\n      // Mouse up goes on doc, so we capture events outside, too\n      document.addEventListener('mouseup', this.mouseUp);\n    }\n\n    if (dblClick) {\n      this.dblClick = evt => {\n        const { x , y } = this.getSVGPoint(evt);\n        dblClick(x, y, evt);\n      }\n\n      document.addEventListener('dblclick', this.dblClick);\n    }\n\n  }\n\n  detachListeners = () => {\n    if (this.mouseMove)\n      this.svg.removeEventListener('mousemove', this.mouseMove);\n\n    if (this.mouseUp)\n      document.removeEventListener('mouseup', this.mouseUp);\n\n    if (this.dblClick)\n      document.removeEventListener('dblclick', this.dblClick);\n  }\n\n  /**\n   * If startOnSingleClick is true, the tool starts on single click\n   * as well as drag. If false, starting strictly requires drag!\n   */\n  start = (evt, startOnSingleClick) => {\n    // Handle SVG conversion on behalf of tool implementations\n    const { x , y } = this.getSVGPoint(evt);\n    this.startDrawing(x, y, startOnSingleClick, evt);\n  }\n\n  /**\n   * Tool implementations MUST override these\n   */\n\n  get isDrawing() {\n    throw new Error(IMPLEMENTATION_MISSING);\n  }\n\n  startDrawing = evt => {\n    throw new Error(IMPLEMENTATION_MISSING);\n  }\n\n  createEditableShape = (annotation, formatters) => {\n    throw new Error(IMPLEMENTATION_MISSING);\n  }\n\n}\n\n// In addition, Tool implementations need to implement the following static methods\n\n// Tool.identifier = '...'\n\nTool.supports = annotation => {\n  throw new Error(IMPLEMENTATION_MISSING);\n}\n\n// Just some convenience shortcuts to client-core, for quicker\n// importing in plugins. (In a way, the intention is to make the\n// Tool class serve as a kind of mini-SDK).\nexport { default as Selection } from '@recogito/recogito-client-core/src/Selection';\nexport { default as WebAnnotation } from '@recogito/recogito-client-core/src/WebAnnotation';\n","import { ToolLike } from './Tool';\n\nconst IMPLEMENTATION_MISSING = \"An implementation is missing\";\n\nexport default class EditableShape extends ToolLike {\n\n  constructor(annotation, g, config, env) {\n    console.log(\"constructing editable shape!\");\n    super(g, config, env);\n\n    this.annotation = annotation;\n  }\n  \n  /**\n   * Implementations MUST override this method!\n   * \n   * Must return the 'g' element with the a9s-annotation class.\n   */\n  get element() {\n    throw new Error(IMPLEMENTATION_MISSING);\n  }\n\n  /**\n   * Implementations MUST override this method!\n   * \n   * The annotation argument MUST be used to update\n   * the current state of the shape. It MUST NOT\n   * be stored as 'this.annotation'! 'this.annotation'\n   * MUST remain the original annotation at the time\n   * this EditableShape was created, because we will\n   * need it again in case the user cancels editing.\n   * \n   * Thinking of it in React terms, 'this.annotation'\n   * has the same purpose as props.annotation, whereas\n   * this method affects state.\n   */\n  updateState = annotation => {\n    throw new Error(IMPLEMENTATION_MISSING);\n  }\n\n}\n","import { SVG_NAMESPACE, addClass } from '../util/SVG';\n\n/** \n * Parses a W3C Web Annotation FragmentSelector conforming\n * to the Media Fragments spec. Supports (well-formed) xywh=pixel\n * and xywh=percent fragments. \n */\nexport const parseRectFragment = (annotation, image) => {\n  const selector = annotation.selector('FragmentSelector');\n\n  if (selector?.conformsTo.startsWith('http://www.w3.org/TR/media-frags')) {\n    const { value } = selector;\n  \n    const format = value.includes(':') ? value.substring(value.indexOf('=') + 1, value.indexOf(':')) : 'pixel';\n    const coords = value.includes(':') ? value.substring(value.indexOf(':') + 1) : value.substring(value.indexOf('=') + 1);\n\n    let [ x, y, w, h ] = coords.split(',').map(parseFloat);\n\n    if (format.toLowerCase() === 'percent') {\n      x = x * image.naturalWidth  / 100;\n      y = y * image.naturalHeight / 100;\n      w = w * image.naturalWidth  / 100;\n      h = h * image.naturalHeight / 100;\n    }\n\n    return { x, y, w, h };\n  }\n}\n\n/** \n * Serializes a (x, y, w, h)-tuple as Media Fragment selector\n * using pixel coordinates.\n */\nconst toPixelRectFragment = (x, y, w, h, image) => ({\n  source: image?.src,\n  selector: {\n    type: \"FragmentSelector\",\n    conformsTo: \"http://www.w3.org/TR/media-frags/\",\n    value: `xywh=pixel:${x},${y},${w},${h}`\n  }\n});\n\n/** \n * Serializes a (x, y, w, h)-tuple as Media Fragment selector \n * using percent coordinates.\n */\nconst toPercentRectFragment = (x, y, w, h, image) => {\n  const px = x / image.naturalWidth  * 100;\n  const py = y / image.naturalHeight * 100;\n  const pw = w / image.naturalWidth  * 100;\n  const ph = h / image.naturalHeight * 100;\n\n  return {\n    source: image.src,\n    selector: {\n      type: \"FragmentSelector\",\n      conformsTo: \"http://www.w3.org/TR/media-frags/\",\n      value: `xywh=percent:${px},${py},${pw},${ph}`\n    }\n  }\n}\n\nexport const toRectFragment = (x, y, w, h, image, fragmentUnit) =>\n  fragmentUnit?.toLowerCase() === 'percent' ?\n    toPercentRectFragment(x, y, w, h, image) :\n    toPixelRectFragment(x, y, w, h, image);\n\n/** Shorthand to apply the given (x, y, w, h) to the SVG shape **/\nconst setXYWH = (shape, x, y, w, h) => {\n  shape.setAttribute('x', x);\n  shape.setAttribute('y', y);\n  shape.setAttribute('width', w);\n  shape.setAttribute('height', h);\n}\n\n\nconst setPointXY = (shape, x, y) => {\n  shape.setAttribute('cx', x);\n  shape.setAttribute('cy', y);\n  shape.setAttribute('r', 7); // TODO make configurable\n}\n\nexport const drawRectMask = (imageDimensions, x, y, w, h) => {\n  const mask = document.createElementNS(SVG_NAMESPACE, 'path');\n  mask.setAttribute('fill-rule', 'evenodd');\n\n  const { naturalWidth, naturalHeight } = imageDimensions;\n  mask.setAttribute('d', `M0 0 h${naturalWidth} v${naturalHeight} h-${naturalWidth} z M${x} ${y} h${w} v${h} h-${w} z`);\n\n  return mask;\n}\n\nexport const setRectMaskSize = (mask, imageDimensions, x, y, w, h) => {\n  const { naturalWidth, naturalHeight } = imageDimensions;\n  mask.setAttribute('d', `M0 0 h${naturalWidth} v${naturalHeight} h-${naturalWidth} z M${x} ${y} h${w} v${h} h-${w} z`);\n}\n\n/** \n * Draws an SVG rectangle, either from an annotation, or an\n * (x, y, w, h)-tuple.\n */\nexport const drawRect = (arg1, arg2, arg3, arg4) => {\n  const { x, y, w, h } = arg1.type === 'Annotation' || arg1.type === 'Selection' ?\n    parseRectFragment(arg1, arg2) : { x: arg1, y: arg2, w: arg3, h: arg4 };\n\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n\n  if (w === 0 && h === 0) {\n    // Edge case: rect is actually a point\n    addClass(g, 'a9s-point');\n    addClass(g, 'a9s-non-scaling');\n    g.setAttribute('transform-origin', `${x} ${y}`);\n\n    const outerPoint  = document.createElementNS(SVG_NAMESPACE, 'circle');\n    const innerPoint  = document.createElementNS(SVG_NAMESPACE, 'circle');\n\n    innerPoint.setAttribute('class', 'a9s-inner');\n    setPointXY(innerPoint, x, y);\n\n    outerPoint.setAttribute('class', 'a9s-outer');\n    setPointXY(outerPoint, x, y);\n\n    g.appendChild(outerPoint);\n    g.appendChild(innerPoint);  \n  } else {\n    const outerRect = document.createElementNS(SVG_NAMESPACE, 'rect');\n    const innerRect = document.createElementNS(SVG_NAMESPACE, 'rect');\n\n    innerRect.setAttribute('class', 'a9s-inner');\n    setXYWH(innerRect, x, y, w, h);\n\n    outerRect.setAttribute('class', 'a9s-outer');\n    setXYWH(outerRect, x, y, w, h);\n\n    g.appendChild(outerRect);\n    g.appendChild(innerRect);\n  }\n\n  return g;\n}\n\n/** Gets the (x, y, w, h)-values from the attributes of the SVG group **/\nexport const getRectSize = g => {\n  const outer = g.querySelector('.a9s-outer');\n\n  if (outer.nodeName === 'rect') {\n    const x = parseFloat(outer.getAttribute('x'));\n    const y = parseFloat(outer.getAttribute('y'));\n    const w = parseFloat(outer.getAttribute('width'));\n    const h = parseFloat(outer.getAttribute('height'));\n\n    return { x, y, w, h };\n  } else {\n    const x = parseFloat(outer.getAttribute('cx'));\n    const y = parseFloat(outer.getAttribute('cy'));\n\n    return { x, y, w: 0, h: 0 };\n  }\n}\n\n/** Applies the (x, y, w, h)-values to the rects in the SVG group **/\nexport const setRectSize = (g, x, y, w, h) => {\n  const inner = g.querySelector('.a9s-inner');\n  const outer = g.querySelector('.a9s-outer');\n\n  if (outer.nodeName === 'rect') {\n    setXYWH(inner, x, y, w, h);\n    setXYWH(outer, x, y, w, h);  \n  } else {\n    setPointXY(inner, x, y);\n    setPointXY(outer, x, y);\n  }\n}\n\n/** \n * Shorthand to get the area (rectangle w x h) from the \n * annotation's fragment selector. \n */\nexport const rectArea = (annotation, image) => {\n  const { w, h } = parseRectFragment(annotation, image);\n  return w * h;\n}\n\n","import { toRectFragment } from '@recogito/annotorious/src/selectors/RectFragment';\n\nexport const isPoint = annotation =>\n  annotation.target.renderedVia?.name === 'point';\n\nexport const toFragment = (x, y, image, fragmentUnit) => ({\n  ...toRectFragment(x, y, 0, 0, image, fragmentUnit),\n  renderedVia: {\n    name: 'point'\n  }\n});","import EditableShape from '@recogito/annotorious/src/tools/EditableShape';\nimport { parseRectFragment } from '@recogito/annotorious/src/selectors/RectFragment';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { toFragment } from './Point';\n\nexport default class EditablePoint extends EditableShape {\n\n  constructor(annotation, g, config, env) {\n    super(annotation, g, config, env);\n\n    this.svg.addEventListener('mousemove', this.onMouseMove);\n    this.svg.addEventListener('mouseup', this.onMouseUp);\n\n    const { x, y } = parseRectFragment(annotation, env.image);\n\n    this.container = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');\n\n    this.point = this.drawHandle(x, y);\n    this.point.addEventListener('mousedown', this.onGrab);\n    \n    this.elementGroup.appendChild(this.point);\n\n    this.container.appendChild(this.elementGroup);\n    g.appendChild(this.container);\n\n    // true if te mouse has grabbed the point\n    this.isGrabbed = false;\n  }\n\n  onScaleChanged = () => \n    this.scaleHandle(this.point);\n\n  get element() {\n    return this.elementGroup;\n  }\n\n  onGrab = () => {\n    this.isGrabbed = true;\n  }\n\n  onMouseMove = evt => {\n    if (evt.button !== 0) return;  // left click\n\n    if (this.isGrabbed) {\n      const {x, y} = this.getSVGPoint(evt);\n\n      this.setHandleXY(this.point, x, y);\n\n      const target = toFragment(x, y, this.env.image, this.config.fragmentUnit);\n      this.emit('update', target);\n    }\n  }\n\n  onMouseUp = () => {\n    this.isGrabbed = false;\n  }\n\n  updateState = annotation => {\n    const { x, y } = parseRectFragment(annotation, this.env.image);\n    this.setHandleXY(this.point, x, y);\n  }\n\n  destroy() {\n    this.svg.removeEventListener('mousemove', this.onMouseMove);\n    this.svg.removeEventListener('mouseup', this.onMouseUp);\n\n    this.container.parentNode.removeChild(this.container);\n    super.destroy();\n  }\n\n}","import Tool, { Selection } from '@recogito/annotorious/src/tools/Tool';\nimport EditablePoint from './EditablePoint';\nimport { toFragment, isPoint } from './Point';\n\nexport default class PointTool extends Tool {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n  }\n\n  startDrawing = (x, y, _, evt) => {\n    // The top-most existing annotation at this position (if any) \n    const annotation = evt.target.closest('.a9s-annotation')?.annotation;\n\n    // The point drawing tool will ALWAYS create a point annotation,\n    // regardless of whether there's already an annotation underneath.\n    // UNLESS the annotation underneath is itself a point!\n    if (!annotation || !isPoint(annotation)) {\n      const element = this.drawHandle(x, y);\n      this.scaleHandle(element);\n\n      this.g.appendChild(element);\n\n      element.annotation = new Selection(toFragment(x, y, this.env.image, this.config.fragmentUnit));\n\n      this.emit('complete', element);\n    } else {\n      this.emit('cancel')\n    }\n  }\n\n  stop = () => {\n    // Nothing to do\n  }\n\n  get isDrawing() {\n    // Point selection is an instant action - the\n    // tool is never an 'drawing' state\n    return false;\n  }\n  \n  createEditableShape = annotation =>\n    new EditablePoint(annotation, this.g, this.config, this.env);\n\n}\n\nPointTool.identifier = 'point';\n\nPointTool.supports = annotation => {\n  // Not needed, since the target.renderedVia property will be evaluated first\n  return false;\n}","import { SVG_NAMESPACE } from '../util/SVG';\n\n/** Helper that forces an un-namespaced node to SVG **/\nconst insertSVGNamespace = originalDoc => {\n  // Serialize and parse for the namespace to take effect on every node\n  const serializer = new XMLSerializer();\n  const str = serializer.serializeToString(originalDoc.documentElement);\n\n  // Doesn't seem that there's a clean cross-browser way for this...\n  const namespaced = str.replace('<svg>', `<svg xmlns=\"${SVG_NAMESPACE}\">`);\n\n  const parser = new DOMParser();\n  const namespacedDoc = parser.parseFromString(namespaced, \"image/svg+xml\");\n  return namespacedDoc.documentElement;\n}\n\nconst sanitize = doc => {\n  // Cf. https://github.com/mattkrick/sanitize-svg#readme  \n  // for the basic approach\n  const cleanEl = el => {\n    Array.from(el.attributes).forEach(attr => {\n      if (attr.name.startsWith('on'))\n        el.removeAttribute(attr.name)\n    });\n  }\n\n  // Remove script tags\n  const scripts = doc.getElementsByTagName('script');\n  Array.from(scripts).reverse().forEach(el =>\n    el.parentNode.removeChild(el));\n\n  // Remove on... attributes\n  cleanEl(doc);\n  Array.from(doc.querySelectorAll('*')).forEach(cleanEl);\n\n  return doc;\n}\n\nexport const svgFragmentToShape = annotation => {\n  const selector = annotation.selector('SvgSelector');\n  if (selector) {\n    const parser = new DOMParser();\n\n    // Parse the XML document, assuming SVG\n    const { value } = selector;\n    const doc = parser.parseFromString(value, \"image/svg+xml\");\n\n    // SVG needs a namespace declaration - check if it's set or insert if not\n    const isPrefixDeclared = doc.lookupPrefix(SVG_NAMESPACE); // SVG declared via prefix\n    const isDefaultNamespaceSVG = doc.lookupNamespaceURI(null); // SVG declared as default namespace\n\n    if (isPrefixDeclared || isDefaultNamespaceSVG) {\n      return sanitize(doc).firstChild;\n    } else {\n      return sanitize(insertSVGNamespace(doc)).firstChild;\n    }\n  }\n}\n\nexport const drawEmbeddedSVG = annotation => {\n  const shape = svgFragmentToShape(annotation);\n\n  // Because we're nitpicky, we don't just draw the shape,\n  // but duplicate it, so we can have inner and an outer lines\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n\n  const inner = shape.cloneNode(true);\n  inner.setAttribute('class', 'a9s-inner');\n\n  const outer = shape.cloneNode(true);\n  outer.setAttribute('class', 'a9s-outer');\n\n  g.appendChild(outer);\n  g.appendChild(inner);\n\n  return g;\n}\n\nexport const toSVGTarget = (shape, image) => {\n  const inner = shape.querySelector('.a9s-inner').cloneNode(true);\n  inner.removeAttribute('class');\n  inner.removeAttribute('xmlns');\n\n  let serialized = inner.outerHTML || new XMLSerializer().serializeToString(inner);\n  serialized = serialized.replace(` xmlns=\"${SVG_NAMESPACE}\"`, '');\n\n  return {\n    source: image?.src,\n    selector: {\n      type: \"SvgSelector\",\n      value: `<svg>${serialized}</svg>`\n    }\n  }\n}\n\nexport const svgArea = annotation => {\n  const shape = svgFragmentToShape(annotation);\n  const nodeName = shape.nodeName.toLowerCase();\n\n  if (nodeName === 'polygon') \n    return polygonArea(shape);\n  else if (nodeName === 'circle')\n    return circleArea(shape);\n  else if (nodeName === 'ellipse')\n    return ellipseArea(shape);\n  else if (nodeName == 'path')\n    return pathArea(shape);\n  else\n    throw `Unsupported SVG shape type: ${nodeName}`;\n}\n\nexport const getAreaOfPoints = points =>{\n  let area = 0;\n  let j = points.length - 1;\n\n  for (let i=0; i < points.length; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i;\n  }\n\n  return Math.abs(0.5 * area);\n}\n\nexport const pointInsidePoygon = (point, polygon) => {\n  \n  var n=polygon.length,\n  is_in=false,\n  x=point[0],\n  y=point[1],\n  x1,x2,y1,y2;\n\nfor(var i=0; i < n-1; ++i){\n  x1=polygon[i][0];\n  x2=polygon[i+1][0];\n  y1=polygon[i][1];\n  y2=polygon[i+1][1];\n\n  if(y < y1 != y < y2 && x < (x2-x1) * (y-y1) / (y2-y1) + x1){\n      is_in=!is_in;\n  }\n}\n\nreturn is_in;\n};\n\nexport const isHole = (polygon1, polygon2) => {\n  // Algorithm checks, if polygon1 is in polygon2\n  for (var point of polygon1){\n    if (!pointInsidePoygon(point, polygon2)) return false\n  }\n  return true;\n}\n\nconst polygonArea = polygon => {\n  const points = polygon.getAttribute('points')\n    .split(' ') // Split x/y tuples\n    .map(xy => xy.split(',').map(str => parseFloat(str.trim())));\n  return getAreaOfPoints(points)\n}\n\nconst circleArea = circle => {\n  const r = circle.getAttribute('r');\n  return r * r * Math.PI;\n}\n\nconst ellipseArea = ellipse => {\n  const rx = ellipse.getAttribute('rx');\n  const ry = ellipse.getAttribute('ry');\n  return rx * ry * Math.PI;\n}\n\nconst pathArea = path => {\n  if (path.getAttribute('d').toUpperCase().includes(\"Z\")){\n    var allcoords = path.getAttribute('d')\n    var polygons =allcoords.split('M');\n    var multiPolygon = []\n    polygons.forEach(function (polygon, index) {\n      if (polygon.length>0){\n        let coords = []\n        polygon=polygon.replace(/ Z/g,\"Z\")\n        polygon=polygon.replace(/Z /g,\"Z\")\n        polygon=polygon.replace(/Z/g,\"\")\n        polygon=polygon.replace(/L /g,\"L\")\n        polygon=polygon.replace(/ L/g,\"L\")\n        var coordsString = polygon.split(\"L\")\n        coordsString.forEach(function(coord, index){\n          coords.push([parseFloat(coord.split(\",\")[0]),parseFloat(coord.split(\",\")[1])]);\n        });\n        if (coords[0] !== coords[coords.length - 1]){\n          coords.push(coords[0])\n        }\n        multiPolygon.push(coords)\n      }\n    })\nif (multiPolygon.length > 1){\n      var area = 0\n      for (let poly1 of multiPolygon) {\n        for (let poly2 of multiPolygon) {\n          if (poly1 !== poly2) {\n            if (isHole(poly1, poly2)) {\n              area -= getAreaOfPoints(poly1)\n            } else {\n              area += getAreaOfPoints(poly1)\n            }\n          }\n        }\n      }\n      return area\n    } else if (multiPolygon.length === 1){\n      return getAreaOfPoints(multiPolygon[0])\n    } else {\n      return 0\n    }\n  } else {\n    const pointList = path.getAttribute('d').split('L');\n    let area = 0;\n  \n    if(pointList.length > 1) {\n      var point = pointList[pointList.length - 1].trim().split(' ');\n      let lastX = parseFloat(point[0]);\n      let lastY = parseFloat(point[1]);\n  \n      point = pointList[0].substring(1).trim().split(' ');\n      let x = parseFloat(point[0]);\n      let y = parseFloat(point[1]);\n      area += (lastX + x) * (lastY - y);\n      lastX = x;\n      lastY = y;\n  \n      for (let i = 1; i < pointList.length; i++) {\n        point = pointList[i].trim().split(' ');\n        x = parseFloat(point[0]);\n        y = parseFloat(point[1]);\n        area += (lastX + x) * (lastY - y);\n        lastX = x;\n        lastY = y;\n      }\n    }\n  \n    return Math.abs(0.5 * area);\n  }\n\n}","import { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\n\n/** Shorthand to apply the given (x, y, r) to the SVG shape **/\nconst setXYR = (shape, x, y, r) => {  \n  shape.setAttribute('cx', x);\n  shape.setAttribute('cy', y);\n  shape.setAttribute('r', r);\n}\n\n/** \n * Draws an SVG circle, either from an annotation, or an\n * (cx, cy, r)-tuple.\n */\nexport const drawCircle = (cx, cy, r) => {\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n  const outerCircle  = document.createElementNS(SVG_NAMESPACE, 'circle');\n  const innerCircle  = document.createElementNS(SVG_NAMESPACE, 'circle');\n\n  innerCircle.setAttribute('class', 'a9s-inner');\n  setXYR(innerCircle, cx, cy, r);\n\n  outerCircle.setAttribute('class', 'a9s-outer');\n  setXYR(outerCircle, cx, cy, r);\n\n  g.appendChild(outerCircle);\n  g.appendChild(innerCircle);\n\n  return g;\n}\n\nexport const setCircleSize = (g, cx, cy, r) => {\n  const innerCircle = g.querySelector('.a9s-inner');\n  const outerCircle = g.querySelector('.a9s-outer');\n  \n  setXYR(innerCircle, cx, cy, r);\n  setXYR(outerCircle, cx, cy, r);\n}\n\nexport const getCircleSize = g => {\n  const outerCircle = g.querySelector('.a9s-outer');\n\n  const cx = parseFloat(outerCircle.getAttribute('cx'));\n  const cy = parseFloat(outerCircle.getAttribute('cy'));\n  const r = parseFloat(outerCircle.getAttribute('r'));\n  \n  return { cx, cy, r };\n}","import { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { getCircleSize } from './Circle';\n\nexport default class CircleMask {\n\n  constructor(imageDimensions, circle) {\n    this.w = imageDimensions.naturalWidth;\n    this.h = imageDimensions.naturalHeight;\n\n    this.circle = circle;\n\n    const { cx, cy, r } = getCircleSize(this.circle);\n    const tx = ((cx + r) > this.w) ? this.w - r : cx;\n    const ty = ((cy + r) > this.h) ? this.h - r : cy + r;\n\n    this.mask = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.mask.setAttribute('fill-rule', 'evenodd');    \n    this.mask.setAttribute('class', 'a9s-selection-mask');\n\n    this.mask.setAttribute('d', `M0 0 h${this.w} v${this.h} h-${this.w} z M${tx} ${ty} a ${r} ${r} 0 1 1 1 0`);\n  }\n\n  redraw = () => {\n    const { cx, cy, r } = getCircleSize(this.circle);\n\n    const tx = ((cx + r) > this.w) ? this.w - r : cx;\n    const ty = ((cy + r) > this.h) ? this.h - r : cy + r;\n\n    this.mask.setAttribute('d', `M0 0 h${this.w} v${this.h} h-${this.w} z M${tx} ${ty} a ${r} ${r} 0 1 1 1 0`);\n  }\n\n  get element() {\n    return this.mask;\n  }\n\n  destroy = () =>\n    this.mask.parentNode.removeChild(this.mask)\n\n}","import { Selection } from '@recogito/annotorious/src/tools/Tool';\nimport { toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { drawCircle, setCircleSize } from './Circle';\nimport Mask from './CircleMask';\n\n/**\n * A 'rubberband' selection tool for creating a circle by\n * clicking and dragging.\n */\nexport default class RubberbandCircle {\n\n  constructor(anchorX, anchorY, g, env) {\n    this.anchor = [ anchorX, anchorY ];\n\n    this.env = env;\n\n    this.group = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.circle = drawCircle(anchorX, anchorY, 2);\n    this.circle.setAttribute('class', 'a9s-selection');\n\n    this.mask = new Mask(env.image, this.circle);\n\n    // We make the selection transparent to \n    // pointer events because it would interfere with the \n    // rendered annotations' mouseleave/enter events\n    this.group.style.pointerEvents = 'none';\n\n    // Additionally, selection remains hidden until \n    // the user actually moves the mouse\n    this.group.style.display = 'none';\n\n    this.group.appendChild(this.mask.element);\n    this.group.appendChild(this.circle);\n\n    g.appendChild(this.group);\n  }\n\n  get element() {\n    return this.circle;\n  }\n\n  dragTo = (oppositeX, oppositeY) => {\n    const { naturalWidth, naturalHeight } = this.env.image;\n\n    // Make visible\n    this.group.style.display = null;\n\n    const w = oppositeX - this.anchor[0];\n    const h = oppositeY - this.anchor[1];\n    const r = Math.max(1, Math.pow(w ** 2 + h ** 2, 0.5) / 2);\n\n    const cx = this.anchor[0] + w / 2;\n    const cy = this.anchor[1] + h / 2;\n\n    if ((cx-r < 0 || cx + r > naturalWidth) || (cy-r < 0 || cy + r > naturalHeight)) return;\n    \n    setCircleSize(this.circle, cx, cy, r);\n    this.mask.redraw();\n  }\n\n  getBoundingClientRect = () => \n    this.circle.getBoundingClientRect();\n\n  toSelection = () => {\n    return new Selection(toSVGTarget(this.group, this.env.image));\n  }\n\n  destroy = () => {\n    this.group.parentNode.removeChild(this.group);\n\n    this.mask = null;\n    this.circle = null;\n    this.group = null;\n  }\n\n}","import { addClass, SVG_NAMESPACE } from './SVG';\n\nconst isFirefox = /firefox/i.test(navigator.userAgent);\n\nconst formatSvgEl = (svgEl, x, y, w, h) => {\n  svgEl.setAttribute('width', w);\n  svgEl.setAttribute('height', h);\n\n  // Argh - Firefox produces broken SVG bounds for nested SVG\n  if (isFirefox) {\n    svgEl.setAttribute('x', 0);\n    svgEl.setAttribute('y', 0);\n    svgEl.setAttribute('transform', `translate(${x}, ${y})`);  \n  } else {\n    svgEl.setAttribute('x', x);\n    svgEl.setAttribute('y', y);\n  }\n}\n\nconst appendFormatterEl = (formatterEl, shape) => {\n  const { x, y, width, height } = shape.getBBox();\n\n  const svgEl = document.createElementNS(SVG_NAMESPACE, 'svg');\n  svgEl.setAttribute('class', 'a9s-formatter-el');\n\n  formatSvgEl(svgEl, x, y, width, height);\n\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n  g.appendChild(formatterEl);y\n\n  svgEl.appendChild(g);\n  \n  shape.append(svgEl);\n}\n\n/**\n * A formatter is a user-defined function that takes an annotation as input,\n * and returns either a string, or an object. If a string is returned, this\n * will be appended to the annotation element CSS class list. Otherwise, the\n * object can have the following properties: \n * \n * - 'className' added to the CSS class list\n * - 'data-*' added as data attributes\n * - 'style' a list of CSS styles (in the form of a string) \n */\n export const setCustomStyle = (shape, annotation) => {\n  if (annotation.getStyle){\n    const style = annotation.getStyle();\n    if (style){\n      for (var i = 0; i < shape.children.length; i++){\n        if (shape.children[i].classList.contains(\"a9s-inner\")){\n          for (let [key, value] of Object.entries(style.inner)){\n            shape.children[i].style[key] = value\n          }\n        } else if (shape.children[i].classList.contains(\"a9s-outer\")){\n          for (let [key, value] of Object.entries(style.outer)){\n            shape.children[i].style[key] = value\n          }\n        }\n      }\n    }  \n  }\n  return shape\n}\nexport const format = (shape, annotation, formatters) => {\n  // The formatter can be undefined\n  console.log(\"formatters\", formatters);\n  if (!formatters)\n    return shape;\n\n  // Merge outputs from all formatter functions into one object\n  const format = formatters.reduce((merged, fn) => {\n    const format = fn(annotation);\n    \n    console.log(\"formating res\", format, fn, annotation.body);\n    if (!format)\n      return merged;\n\n    if (typeof format === 'string' || format instanceof String) {\n      merged.className = merged.className ? `${merged.className} ${format}` : format; \n    } else if (format.nodeType === Node.ELEMENT_NODE) {\n      merged.elements = merged.elements ? [...merged.elements, format] : [format];\n    } else {\n      const { className, style, element } = format;\n\n      if (className)\n        merged.className = merged.className ? `${merged.className} ${className}` : className;\n\n      if (style)\n        merged.style = merged.style ? `${merged.style} ${style}` : style;\n\n      if (element)\n        merged.elements = merged.elements ? [...merged.elements, element] : [element];\n    }\n\n    // Copy data attributes\n    for (const key in format) {\n      if (format.hasOwnProperty(key) && key.startsWith('data-')) {\n        merged[key] = format[key];\n      }\n    }\n\n    return merged;\n  }, {});\n\n  const { className, style, elements } = format;\n\n  if (className)\n    addClass(shape, className);\n\n  if (style) {\n    const outer = shape.querySelector('.a9s-outer');\n    const inner = shape.querySelector('.a9s-inner');\n\n    if (outer && inner) {\n      outer.setAttribute('style', 'display:none');\n      inner.setAttribute('style', style);\n    } else {\n      shape.setAttribute('style', style);\n    }\n  }\n\n  if (elements)\n    elements.forEach(el => appendFormatterEl(el, shape));\n\n  for (const key in format) {\n    if (format.hasOwnProperty(key) && key.startsWith('data-')) {\n      shape.setAttribute(key, format[key]);\n    }\n  }\n}\n\nexport const setFormatterElSize = (group, x, y, w, h) => {\n  const formatterEl = group.querySelector('.a9s-formatter-el');\n  if (formatterEl)\n    formatSvgEl(formatterEl, x, y, w, h);\n}","import EditableShape from '@recogito/annotorious/src/tools/EditableShape';\nimport { drawEmbeddedSVG, svgFragmentToShape, toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { format, setFormatterElSize } from '@recogito/annotorious/src/util/Formatting';\nimport { getCircleSize, setCircleSize } from './Circle';\nimport Mask from './CircleMask';\n\n/**\n * An editable circle shape.\n */\nexport default class EditableCircle extends EditableShape {\n\n  constructor(annotation, g, config, env) {\n    super(annotation, g, config, env);\n\n    this.svg.addEventListener('mousemove', this.onMouseMove);\n    this.svg.addEventListener('mouseup', this.onMouseUp);\n\n    // SVG markup for this class looks like this:\n    // \n    // <g>\n    //   <path class=\"a9s-selection mask\"... />\n    //   <g> <-- return this node as .element\n    //     <circle class=\"a9s-outer\" ... />\n    //     <circle class=\"a9s-inner\" ... />\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //   </g> \n    // </g>\n\n    // 'g' for the editable circle compound shape\n    this.containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.circle = drawEmbeddedSVG(annotation);\n    this.circle.querySelector('.a9s-inner')\n      .addEventListener('mousedown', this.onGrab(this.circle));\n\n    this.mask = new Mask(env.image, this.circle);\n\n    this.containerGroup.appendChild(this.mask.element);\n\n    // The 'element' = circle + handles\n    this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');\n    this.elementGroup.appendChild(this.circle);    \n\n    const { cx, cy, r } = getCircleSize(this.circle);\n\n    this.handles = [\n      [ cx, cy - r ],\n      [ cx + r, cy ],\n      [ cx, cy + r ],\n      [ cx - r, cy ]\n    ].map(t => { \n      const [ x, y ] = t;\n      const handle = this.drawHandle(x, y);\n\n      handle.addEventListener('mousedown', this.onGrab(handle));\n      this.elementGroup.appendChild(handle);\n\n      return handle;\n    });\n\n    this.containerGroup.appendChild(this.elementGroup);\n    g.appendChild(this.containerGroup);\n\n    format(this.circle, annotation, config.formatter);\n\n    // The grabbed element (handle or entire group), if any\n    this.grabbedElem = null; \n\n    // Mouse xy offset inside the shape, if mouse pressed\n    this.grabbedAt = null;\n  }\n\n  setSize = (cx, cy, r) => {\n    setCircleSize(this.circle, cx, cy, r);\n    this.mask.redraw();\n    setFormatterElSize(this.elementGroup, cx, cy, r, r);\n\n    const [ topleft, topright, bottomright, bottomleft] = this.handles;\n    this.setHandleXY(topleft, cx, cy - r);\n    this.setHandleXY(topright, cx + r, cy);\n    this.setHandleXY(bottomright, cx, cy + r);\n    this.setHandleXY(bottomleft, cx - r, cy);\n  }\n\n  stretchCorners = (draggedHandleIdx, anchorHandle, mousePos) => {\n    const anchor = this.getHandleXY(anchorHandle);\n\n    var mouseX = mousePos.x;\n    var mouseY = mousePos.y;\n    var width = 0;\n    var height = 0;\n    var r;\n    if (draggedHandleIdx == 0 || draggedHandleIdx == 2) {\n      mouseX = anchor.x;\n      height = mouseY - anchor.y;\n      r = Math.abs(height) / 2;\n    } else {\n      mouseY = anchor.y;\n      width = mouseX - anchor.x;\n      r = Math.abs(width) / 2;\n    }\n\n    const x = width > 0 ? anchor.x : mouseX;\n    const y = height > 0 ? anchor.y : mouseY;\n    const w = Math.abs(width);\n    const h = Math.abs(height);\n    const cx = x + w/2;\n    const cy = y + h/2;\n\n    setCircleSize(this.circle, cx, cy, r);\n    this.mask.redraw();\n    setFormatterElSize(this.elementGroup, cx, cy, r, r);\n\n    if (draggedHandleIdx == 0 || draggedHandleIdx == 2) {\n      var idx0 = 0;\n      var idx2 = 2;\n      if(draggedHandleIdx == 0 && height > 0 || draggedHandleIdx == 2 && height < 0) {\n        idx0 = 2;\n        idx2 = 0;\n      }\n      this.setHandleXY(this.handles[idx0], cx, cy - r);\n      this.setHandleXY(this.handles[idx2], cx, cy + r);\n      this.setHandleXY(this.handles[1], cx + r, cy);\n      this.setHandleXY(this.handles[3], cx - r, cy);\n    } else {\n      var idx3 = 3;\n      var idx1 = 1;\n      if (draggedHandleIdx == 1 && width > 0 || draggedHandleIdx == 3 && width < 0) {\n        idx3 = 1;\n        idx1 = 3;\n      }\n      this.setHandleXY(this.handles[idx3], cx + r, cy);\n      this.setHandleXY(this.handles[idx1], cx - r, cy);\n      this.setHandleXY(this.handles[0], cx, cy - r);\n      this.setHandleXY(this.handles[2], cx, cy + r);\n    }\n  }\n\n  onGrab = grabbedElem => evt => {\n    this.grabbedElem = grabbedElem; \n    \n    const pos = this.getSVGPoint(evt);\n    const { cx, cy } = getCircleSize(this.circle);\n    \n    this.grabbedAt = { x: pos.x - cx, y: pos.y - cy };\n  }\n\n  onMouseMove = evt => {\n    const constrain = (coord, max) =>\n      coord < 0 ? 0 : ( coord > max ? max : coord);\n\n    if (this.grabbedElem) {\n      const pos = this.getSVGPoint(evt);\n\n      if (this.grabbedElem === this.circle) {\n        const { r } = getCircleSize(this.circle);\n\n        const { naturalWidth, naturalHeight } = this.env.image;\n\n        const cx = Math.max(constrain(pos.x - this.grabbedAt.x, naturalWidth - r), r);\n        const cy = Math.max(constrain(pos.y - this.grabbedAt.y, naturalHeight - r), r);\n\n        this.setSize(cx, cy, r); \n        this.emit('update', toSVGTarget(this.circle, this.env.image)); \n      } else {\n        // Mouse position replaces one of the corner coords, depending\n        // on which handle is the grabbed element\n        const handleIdx = this.handles.indexOf(this.grabbedElem);\n        const oppositeHandle = handleIdx < 2 ? \n          this.handles[handleIdx + 2] : this.handles[handleIdx - 2];\n\n        this.stretchCorners(handleIdx, oppositeHandle, pos);\n        this.emit('update', toSVGTarget(this.circle, this.env.image));\n      }\n    }\n  }\n\n  onMouseUp = () => {\n    this.grabbedElem = null;\n    this.grabbedAt = null;\n  }\n\n  get element() { \n    return this.elementGroup; \n  }\n\n  updateState = annotation => {\n    const shape = svgFragmentToShape(annotation);\n\n    const cx = parseFloat(shape.getAttribute('cx'));\n    const cy = parseFloat(shape.getAttribute('cy'));\n    const r =  parseFloat(shape.getAttribute('r'));\n\n    this.setSize(cx, cy, r);\n  }\n\n  destroy() {\n    this.containerGroup.parentNode.removeChild(this.containerGroup);\n    super.destroy();\n  }\n\n}\n","import Tool from '@recogito/annotorious/src/tools/Tool';\nimport RubberbandCircle from './RubberbandCircle';\nimport EditableCircle from './EditableCircle';\n\n/**\n * A rubberband selector for circle selections.\n */\nexport default class RubberbandCircleTool extends Tool {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n\n    this.rubberband = null;\n  }\n\n  startDrawing = (x, y) => {\n    this.attachListeners({\n      mouseMove: this.onMouseMove,\n      mouseUp: this.onMouseUp\n    });\n\n    this.rubberband = new RubberbandCircle(x, y, this.g, this.env);\n  }\n\n  stop = () => {\n    if (this.rubberband) {\n      this.rubberband.destroy();\n      this.rubberband = null;\n    }\n  }\n\n  onMouseMove = (x, y) =>\n    this.rubberband.dragTo(x, y);\n  \n  onMouseUp = () => {\n    this.detachListeners();\n    this.started = false;\n\n    const { width, height } = this.rubberband.getBoundingClientRect();\n\n    const minWidth = this.config.minSelectionWidth || 4;\n    const minHeight = this.config.minSelectionHeight || 4;\n\n    if (width >= minWidth && height >= minHeight) {\n      // Emit the SVG shape with selection attached    \n      const { element } = this.rubberband;\n      element.annotation = this.rubberband.toSelection();\n\n      // Emit the completed shape...\n      this.emit('complete', element);\n    } else {\n      this.emit('cancel');\n    }\n\n    this.stop();\n  }\n\n  get isDrawing() {\n    return this.rubberband != null;\n  }\n  \n  createEditableShape = annotation =>\n    new EditableCircle(annotation, this.g, this.config, this.env);\n\n}\n\nRubberbandCircleTool.identifier = 'circle';\n\nRubberbandCircleTool.supports = annotation => {\n  const selector = annotation.selector('SvgSelector');\n  if (selector)\n    return selector.value?.match(/^<svg.*<circle/g);\n}","import { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\n\n/** Shorthand to apply the given (x, y, rx, ry) to the SVG shape **/\nconst setXYR = (shape, x, y, rx, ry) => {  \n  shape.setAttribute('cx', x);\n  shape.setAttribute('cy', y);\n  shape.setAttribute('rx', rx);\n  shape.setAttribute('ry', ry);\n}\n\n/** \n * Draws an SVG ellipse, either from an annotation, or an\n * (cx, cy, rx, ry)-tuple.\n */\nexport const drawEllipse = (cx, cy, rx, ry) => {\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n  const innerEllipse  = document.createElementNS(SVG_NAMESPACE, 'ellipse');\n  const outerEllipse  = document.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n  innerEllipse.setAttribute('class', 'a9s-inner');\n  setXYR(innerEllipse, cx, cy, rx, ry);\n\n  outerEllipse.setAttribute('class', 'a9s-outer');\n  setXYR(outerEllipse, cx, cy, rx, ry);\n\n  g.appendChild(outerEllipse);\n  g.appendChild(innerEllipse);\n\n  return g;\n}\n\nexport const setEllipseSize = (g, cx, cy, rx, ry) => {\n  const innerEllipse = g.querySelector('.a9s-inner');\n  const outerEllipse = g.querySelector('.a9s-outer');\n\n  setXYR(innerEllipse, cx, cy, rx, ry);\n  setXYR(outerEllipse, cx, cy, rx, ry);\n}\n\nexport const getEllipseSize = g => {\n  const outerEllipse = g.querySelector('.a9s-outer');\n\n  const cx = parseFloat(outerEllipse.getAttribute('cx'));\n  const cy = parseFloat(outerEllipse.getAttribute('cy'));\n  const rx = parseFloat(outerEllipse.getAttribute('rx'));\n  const ry = parseFloat(outerEllipse.getAttribute('ry'));\n  \n  return { cx, cy, rx, ry };\n}","import { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { getEllipseSize } from './Ellipse';\n\nexport default class EllipseMask {\n\n  constructor(imageDimensions, ellipse) {\n    this.w = imageDimensions.naturalWidth;\n    this.h = imageDimensions.naturalHeight;\n\n    this.ellipse = ellipse;\n\n    const { cx, cy, rx, ry } = getEllipseSize(this.ellipse);\n\n    const ty = cy + ry;\n\n    this.mask = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.mask.setAttribute('fill-rule', 'evenodd');    \n    this.mask.setAttribute('class', 'a9s-selection-mask');\n\n    this.mask.setAttribute('d', `M0 0 h${this.w} v${this.h} h-${this.w} z M${cx} ${ty} a ${rx} ${ry} 0 1 1 1 0`);\n  }\n\n  redraw = () => {\n    const { cx, cy, rx, ry } = getEllipseSize(this.ellipse);\n\n    const ty = cy + ry;\n\n    this.mask.setAttribute('d', `M0 0 h${this.w} v${this.h} h-${this.w} z M${cx} ${ty} a ${rx} ${ry} 0 1 1 1 0`);\n  }\n\n  get element() {\n    return this.mask;\n  }\n\n  destroy = () =>\n    this.mask.parentNode.removeChild(this.mask)\n\n}","import { Selection } from '@recogito/annotorious/src/tools/Tool';\nimport { toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { drawEllipse, setEllipseSize } from './Ellipse';\nimport Mask from './EllipseMask';\n\n/**\n * A 'rubberband' selection tool for creating a ellipse by\n * clicking and dragging.\n */\nexport default class RubberbandEllipse {\n\n  constructor(anchorX, anchorY, g, env) {\n    this.anchor = [ anchorX, anchorY ];\n\n    this.env = env;\n\n    this.group = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.ellipse = drawEllipse(anchorX, anchorY, 2);\n    this.ellipse.setAttribute('class', 'a9s-selection');\n\n    this.mask = new Mask(env.image, this.ellipse);\n\n    // We make the selection transparent to \n    // pointer events because it would interfere with the \n    // rendered annotations' mouseleave/enter events\n    this.group.style.pointerEvents = 'none';\n\n    // Additionally, selection remains hidden until \n    // the user actually moves the mouse\n    this.group.style.display = 'none';\n\n    this.group.appendChild(this.mask.element);\n    this.group.appendChild(this.ellipse);\n\n    g.appendChild(this.group);\n  }\n\n  get element() {\n    return this.ellipse;\n  }\n\n  dragTo = (oppositeX, oppositeY) => {\n    // Make visible\n    this.group.style.display = null;\n\n    const w = oppositeX - this.anchor[0];\n    const h = oppositeY - this.anchor[1];\n\n    const cx = w > 0 ? this.anchor[0] + w / 2 : oppositeX + w / 2;\n    const cy = h > 0 ? this.anchor[1] + h / 2 : oppositeY + h / 2;\n\n    const rx = Math.abs(w / 2);\n    const ry = Math.abs(h / 2);\n\n    setEllipseSize(this.ellipse, cx, cy, rx, ry);\n    this.mask.redraw();\n  }\n\n  getBoundingClientRect = () => \n    this.ellipse.getBoundingClientRect();\n\n  toSelection = () => {\n    return new Selection(toSVGTarget(this.group, this.env.image));\n  }\n\n  destroy = () => {\n    this.group.parentNode.removeChild(this.group);\n\n    this.mask = null;\n    this.ellipse = null;\n    this.group = null;\n  }\n\n}","import EditableShape from '@recogito/annotorious/src/tools/EditableShape';\nimport { drawEmbeddedSVG, svgFragmentToShape, toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { format, setFormatterElSize } from '@recogito/annotorious/src/util/Formatting';\nimport { getEllipseSize, setEllipseSize } from './Ellipse';\nimport Mask from './EllipseMask';\n\n/**\n * An editable ellipse shape.\n */\nexport default class EditableEllipse extends EditableShape {\n\n  constructor(annotation, g, config, env) {\n    super(annotation, g, config, env);\n\n    this.svg.addEventListener('mousemove', this.onMouseMove);\n    this.svg.addEventListener('mouseup', this.onMouseUp);\n\n    // SVG markup for this class looks like this:\n    // \n    // <g>\n    //   <path class=\"a9s-selection mask\"... />\n    //   <g> <-- return this node as .element\n    //     <ellipse class=\"a9s-outer\" ... />\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //   </g> \n    // </g>\n\n    // 'g' for the editable ellipse compound shape\n    this.containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.ellipse = drawEmbeddedSVG(annotation);\n    this.ellipse.querySelector('.a9s-inner')\n      .addEventListener('mousedown', this.onGrab(this.ellipse));\n\n    this.mask = new Mask(env.image, this.ellipse);\n\n    this.containerGroup.appendChild(this.mask.element);\n\n    // The 'element' = ellipse + handles\n    this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');\n    this.elementGroup.appendChild(this.ellipse);    \n\n    const { cx, cy, rx, ry } = getEllipseSize(this.ellipse);\n\n    this.handles = [\n      [ cx, cy - ry ],\n      [ cx + rx, cy ],\n      [ cx, cy + ry ],\n      [ cx - rx, cy ]\n    ].map(t => { \n      const [ x, y ] = t;\n      const handle = this.drawHandle(x, y);\n\n      handle.addEventListener('mousedown', this.onGrab(handle));\n      this.elementGroup.appendChild(handle);\n\n      return handle;\n    });\n\n    this.containerGroup.appendChild(this.elementGroup);\n    g.appendChild(this.containerGroup);\n\n    format(this.ellipse, annotation, config.formatter);\n\n    // The grabbed element (handle or entire group), if any\n    this.grabbedElem = null; \n\n    // Mouse xy offset inside the shape, if mouse pressed\n    this.grabbedAt = null;\n  }\n\n  setSize = (cx, cy, rx, ry) => {\n    setEllipseSize(this.ellipse, cx, cy, rx, ry);\n    this.mask.redraw();\n    setFormatterElSize(this.elementGroup, cx, cy, rx, ry);\n\n    const [ topleft, topright, bottomright, bottomleft] = this.handles;\n    this.setHandleXY(topleft, cx, cy - ry);\n    this.setHandleXY(topright, cx + rx, cy);\n    this.setHandleXY(bottomright, cx, cy + ry);\n    this.setHandleXY(bottomleft, cx - rx, cy);\n  }\n\n  stretchCorners = (draggedHandleIdx, anchorHandle, leftHandle, mousePos) => {\n    const anchor = this.getHandleXY(anchorHandle);\n    const anchorLeft = this.getHandleXY(leftHandle);\n\n    var mouseX = mousePos.x;\n    var mouseY = mousePos.y;\n    var rx = 0;\n    var ry = 0;\n    if(draggedHandleIdx == 0 || draggedHandleIdx == 2) {\n      mouseX = anchor.x;\n    } else {\n      mouseY = anchor.y;\n    }\n\n    const width = mouseX - anchor.x;\n    const height = mouseY - anchor.y;\n    const x = width > 0 ? anchor.x : mouseX;\n    const y = height > 0 ? anchor.y : mouseY;\n    const w = Math.abs(width);\n    const h = Math.abs(height);\n    const cx = x + w/2;\n    const cy = y + h/2;\n    var rx = w/2;\n    var ry = h/2;\n    if(draggedHandleIdx == 0 || draggedHandleIdx == 2) {\n      rx = Math.abs(anchor.x - anchorLeft.x);\n    } else {\n      ry = Math.abs(anchor.y - anchorLeft.y);\n    }\n\n    setEllipseSize(this.ellipse, cx, cy, rx, ry);\n    this.mask.redraw();\n    setFormatterElSize(this.elementGroup, cx, cy, rx, ry);\n\n    if (draggedHandleIdx == 0 || draggedHandleIdx == 2) {\n      var idx0 = 0;\n      var idx2 = 2;\n      if(draggedHandleIdx == 0 && height > 0 || draggedHandleIdx == 2 && height < 0) {\n        idx0 = 2;\n        idx2 = 0;\n      }\n      this.setHandleXY(this.handles[idx0], cx, cy - ry);\n      this.setHandleXY(this.handles[idx2], cx, cy + ry);\n      this.setHandleXY(this.handles[1], cx + rx, cy);\n      this.setHandleXY(this.handles[3], cx - rx, cy);\n    } else {\n      var idx3 = 3;\n      var idx1 = 1;\n      if (draggedHandleIdx == 1 && width > 0 || draggedHandleIdx == 3 && width < 0) {\n        idx3 = 1;\n        idx1 = 3;\n      }\n      this.setHandleXY(this.handles[idx3], cx + rx, cy);\n      this.setHandleXY(this.handles[idx1], cx - rx, cy);\n      this.setHandleXY(this.handles[0], cx, cy - ry);\n      this.setHandleXY(this.handles[2], cx, cy + ry);\n    }\n  }\n\n  onGrab = grabbedElem => evt => {\n    this.grabbedElem = grabbedElem; \n\n    const pos = this.getSVGPoint(evt);\n    const { cx, cy } = getEllipseSize(this.ellipse);\n\n    this.grabbedAt = { x: pos.x - cx, y: pos.y - cy };\n  }\n\n  onMouseMove = evt => {\n    const constrain = (coord, max) =>\n      coord < 0 ? 0 : ( coord > max ? max : coord);\n\n    if (this.grabbedElem) {\n      const pos = this.getSVGPoint(evt);\n\n      if (this.grabbedElem === this.ellipse) {\n        const { rx, ry } = getEllipseSize(this.ellipse);\n\n        const { naturalWidth, naturalHeight } = this.env.image;\n\n        const cx = constrain(pos.x - this.grabbedAt.x, naturalWidth - rx);\n        const cy = constrain(pos.y - this.grabbedAt.y, naturalHeight - ry);\n\n        this.setSize(cx, cy, rx, ry); \n        this.emit('update', toSVGTarget(this.ellipse, this.env.image));\n      } else {\n        // Mouse position replaces one of the corner coords, depending\n        // on which handle is the grabbed element\n        const handleIdx = this.handles.indexOf(this.grabbedElem);\n        const oppositeHandle = handleIdx < 2 ? \n          this.handles[handleIdx + 2] : this.handles[handleIdx - 2];\n        const leftHandle = this.handles[(handleIdx + 3) % 4];\n\n        this.stretchCorners(handleIdx, oppositeHandle, leftHandle, pos);\n        this.emit('update', toSVGTarget(this.ellipse, this.env.image));\n      }\n    }\n  }\n\n  onMouseUp = () => {\n    this.grabbedElem = null;\n    this.grabbedAt = null;\n  }\n\n  get element() { \n    return this.elementGroup; \n  }\n\n  updateState = annotation => {\n    const shape = svgFragmentToShape(annotation);\n\n    const cx = parseFloat(shape.getAttribute('cx'));\n    const cy = parseFloat(shape.getAttribute('cy'));\n    const rx = parseFloat(shape.getAttribute('rx'));\n    const ry = parseFloat(shape.getAttribute('ry'));\n    \n    this.setSize(cx, cy, rx, ry);\n  }\n\n  destroy() {\n    this.containerGroup.parentNode.removeChild(this.containerGroup);\n    super.destroy();\n  }\n\n}","import Tool from '@recogito/annotorious/src/tools/Tool';\nimport RubberbandEllipse from './RubberbandEllipse';\nimport EditableEllipse from './EditableEllipse';\n\n/**\n * A rubberband selector for ellipse selections.\n */\nexport default class RubberbandEllipseTool extends Tool {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n\n    this.rubberband = null;\n  }\n\n  startDrawing = (x, y) => {\n    this.attachListeners({\n      mouseMove: this.onMouseMove,\n      mouseUp: this.onMouseUp\n    });\n\n    this.rubberband = new RubberbandEllipse(x, y, this.g, this.env);\n  }\n\n  stop = () => {\n    if (this.rubberband) {\n      this.rubberband.destroy();\n      this.rubberband = null;\n    }\n  }\n\n  onMouseMove = (x, y) =>\n    this.rubberband.dragTo(x, y);\n  \n  onMouseUp = () => {\n    this.detachListeners();\n    this.started = false;\n\n    const { width, height } = this.rubberband.getBoundingClientRect();\n\n    const minWidth = this.config.minSelectionWidth || 4;\n    const minHeight = this.config.minSelectionHeight || 4;\n\n    if (width >= minWidth && height >= minHeight) {\n      // Emit the SVG shape with selection attached    \n      const { element } = this.rubberband;\n      element.annotation = this.rubberband.toSelection();\n\n      // Emit the completed shape...\n      this.emit('complete', element);\n    } else {\n      this.emit('cancel');\n    }\n\n    this.stop();\n  }\n\n  get isDrawing() {\n    return this.rubberband != null;\n  }\n  \n  createEditableShape = annotation =>\n    new EditableEllipse(annotation, this.g, this.config, this.env);\n\n}\n\nRubberbandEllipseTool.identifier = 'ellipse';\n\nRubberbandEllipseTool.supports = annotation => {\n  const selector = annotation.selector('SvgSelector');\n  if (selector)\n    return selector.value?.match(/^<svg.*<ellipse/g);\n}","import { Selection } from '@recogito/annotorious/src/tools/Tool';\nimport { toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\n// TODO optional: mask to dim the outside area\n//import Mask from './FreehandMask';\n\n/**\n * A 'rubberband' selection tool for creating freehand drawing by\n * clicking and dragging.\n */\nexport default class RubberbandFreehand {\n\n  constructor(anchor, g, env) {\n    this.points = [ anchor ];\n\n    this.env = env;\n\n    this.group = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.freehand = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.freehand.setAttribute('class', 'a9s-selection');\n\n    this.outer = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.outer.setAttribute('class', 'a9s-outer');\n\n    this.inner = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.inner.setAttribute('class', 'a9s-inner');\n\n    this.setPoints(this.points);\n\n   // TODO optional: mask to dim the outside area\n   // this.mask = new Mask(env.image, this.inner);\n\n    this.freehand.appendChild(this.outer);\n    this.freehand.appendChild(this.inner);\n\n    // Additionally, selection remains hidden until \n    // the user actually moves the mouse\n    this.group.style.display = 'none';\n\n   // TODO optional: mask to dim the outside area\n   // this.group.appendChild(this.mask.element);\n    this.group.appendChild(this.freehand);\n\n    g.appendChild(this.group);\n  }\n\n  setPoints = points => {\n    var str = points.map(pt => `L${pt[0]} ${pt[1]}`).join(' ');\n    str = 'M' + str.substring(1);\n    this.outer.setAttribute('d', str);\n    this.inner.setAttribute('d', str);\n  }\n\n  getBoundingClientRect = () =>\n    this.outer.getBoundingClientRect();\n\n  dragTo = xy => {\n    // Make visible\n    this.group.style.display = null;\n\n    //TODO optional: edge smoothing\n\n    this.addPoint(xy);\n\n   // TODO optional: mask to dim the outside area\n   // this.mask.redraw();\n  }\n\n  addPoint = xy => {\n    this.points = [ ...this.points, xy ];\n    this.setPoints(this.points);   \n   // TODO optional: mask to dim the outside area\n   // this.mask.redraw();\n  }\n\n  get element() {\n    return this.freehand;\n  }\n\n  destroy = () => {\n    this.group.parentNode.removeChild(this.group);\n    this.freehand = null;    \n    this.group = null;\n  }\n\n  toSelection = () => {\n    return new Selection(toSVGTarget(this.group, this.env.image));\n  }\n\n}\n","import EditableShape from '@recogito/annotorious/src/tools/EditableShape';\nimport { drawEmbeddedSVG, svgFragmentToShape, toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { format, setFormatterElSize } from '@recogito/annotorious/src/util/Formatting';\n// TODO optional: mask to dim the outside area\n//import Mask from './FreehandMask';\n\nconst getPoints = shape => {\n  const pointList = shape.getAttribute('d').split('L');\n  const points = [];\n  if(pointList.length > 0) {\n    var point = pointList[0].substring(1).trim().split(' ');\n    points.push({ x: parseFloat(point[0]), y: parseFloat(point[1]) });\n\n    for (let i = 1; i < pointList.length; i++) {\n      var point = pointList[i].trim().split(' ');\n      points.push({ x: parseFloat(point[0]), y: parseFloat(point[1]) });\n    }\n  }\n\n  return points;\n}\n\nconst getBBox = shape => {\n  return shape.querySelector('.a9s-inner').getBBox();\n}\n\n/**\n * An editable freehand drawing.\n */\nexport default class EditableFreehand extends EditableShape {\n\n  constructor(annotation, g, config, env) {\n    super(annotation, g, config, env);\n\n    this.svg.addEventListener('mousemove', this.onMouseMove);\n    this.svg.addEventListener('mouseup', this.onMouseUp);\n\n    // SVG markup for this class looks like this:\n    // \n    // <g>\n    //   <path class=\"a9s-selection mask\"... />\n    //   <g> <-- return this node as .element\n    //     <polygon class=\"a9s-outer\" ... />\n    //     <polygon class=\"a9s-inner\" ... />\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     ...\n    //   </g> \n    // </g>\n\n    // 'g' for the editable free drawing compound shape\n    this.containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.shape = drawEmbeddedSVG(annotation);\n\n   // TODO optional: mask to dim the outside area\n   // this.mask = new Mask(env.image, this.shape.querySelector('.a9s-inner'));\n    \n   // this.containerGroup.appendChild(this.mask.element);\n\n    this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');\n    this.elementGroup.appendChild(this.shape);\n\n    this.containerGroup.appendChild(this.elementGroup);\n    g.appendChild(this.containerGroup);\n\n    format(this.shape, annotation, config.formatter);\n\n    this.shape.querySelector('.a9s-inner')\n      .addEventListener('mousedown', this.onGrab(this.shape));\n\n    const { x, y, width, height } = getBBox(this.shape);\n\n    // TODO optional: handles to stretch the shape\n/*    this.handles = [\n      [ x, y ], \n      [ x + width, y ], \n      [ x + width, y + height ], \n      [ x, y + height ]\n    ].map(t => { \n      const [ x, y ] = t;\n      const handle = this.drawHandle(x, y);\n\n      handle.addEventListener('mousedown', this.onGrab(handle));\n      this.elementGroup.appendChild(handle);\n\n      return handle;\n    });*/\n\n    // The grabbed element (handle or entire shape), if any\n    this.grabbedElem = null;\n\n    // Mouse grab point\n    this.grabbedAt = null;\n  }\n\n  setPoints = (points) => {\n    // Not using .toFixed(1) because that will ALWAYS\n    // return one decimal, e.g. \"15.0\" (when we want \"15\")\n    const round = num => Math.round(10 * num) / 10;\n\n    var str = points.map(pt => `L${round(pt.x)} ${round(pt.y)}`).join(' ');\n    str = 'M' + str.substring(1);\n\n    const inner = this.shape.querySelector('.a9s-inner');\n    inner.setAttribute('d', str);\n\n    const outer = this.shape.querySelector('.a9s-outer');\n    outer.setAttribute('d', str);\n\n    const { x, y, width, height } = outer.getBBox();\n\n    // TODO optional: mask to dim the outside area\n    // this.mask.redraw();\n\n    // TODO optional: handles to stretch the shape\n/*    const [ topleft, topright, bottomright, bottomleft] = this.handles;\n\n    this.setHandleXY(topleft, x, y);\n    this.setHandleXY(topright, x + width, y);\n    this.setHandleXY(bottomright, x + width, y + height);\n    this.setHandleXY(bottomleft, x, y + height);*/\n\n    setFormatterElSize(this.elementGroup, x, y, width, height);\n  }\n\n    // TODO optional: handles to stretch the shape\n/*  stretchCorners = (draggedHandleIdx, anchorHandle, mousePos) => {\n    const anchor = this.getHandleXY(anchorHandle);\n  }*/\n\n  onGrab = grabbedElem => evt => {\n    this.grabbedElem = grabbedElem;\n    const pos = this.getSVGPoint(evt);\n    this.grabbedAt = { x: pos.x, y: pos.y };\n  }\n\n  onMouseMove = evt => {\n    const constrain = (coord, delta, max) =>\n      coord + delta < 0 ? -coord : (coord + delta > max ? max - coord : delta);\n\n    if (this.grabbedElem) {\n      const pos = this.getSVGPoint(evt);\n\n      const { x, y, width, height } = getBBox(this.shape);\n\n      if (this.grabbedElem === this.shape) {\n\n        const { naturalWidth, naturalHeight } = this.env.image;\n\n        const dx = constrain(x, pos.x - this.grabbedAt.x, naturalWidth - width);\n        const dy = constrain(y, pos.y - this.grabbedAt.y, naturalHeight - height);\n\n        const inner = this.shape.querySelector('.a9s-inner');\n        const updatedPoints = getPoints(inner).map(pt => ({ x: pt.x + dx, y: pt.y + dy }));\n\n        this.grabbedAt = pos;\n\n        this.setPoints(updatedPoints);\n\n        this.emit('update', toSVGTarget(this.shape, this.env.image));\n      }\n      // TODO optional: handles to stretch the shape\n      /* else {\n        const handleIdx = this.handles.indexOf(this.grabbedElem);\n        const oppositeHandle = handleIdx < 2 ? \n          this.handles[handleIdx + 2] : this.handles[handleIdx - 2];\n\n        this.stretchCorners(handleIdx, oppositeHandle, pos);\n\n        this.emit('update', toSVGTarget(this.shape, this.env.image));\n      }*/\n    }\n  }\n\n  onMouseUp = evt => {\n    this.grabbedElem = null;\n    this.grabbedAt = null;\n  }\n\n  get element() {\n    return this.elementGroup;\n  }\n\n  updateState = annotation => {\n    const points = getPoints(svgFragmentToShape(annotation));\n    this.setPoints(points);\n  }\n\n  destroy = () => {\n    this.containerGroup.parentNode.removeChild(this.containerGroup);\n    super.destroy();\n  }\n\n}\n","import Tool from '@recogito/annotorious/src/tools/Tool';\nimport RubberbandFreehand from './RubberbandFreehand';\nimport EditableFreehand from './EditableFreehand';\n\n/**\n * A rubberband selector for freehand fragments.\n */\nexport default class RubberbandFreehandTool extends Tool {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n\n    this._isDrawing = false;\n  }\n\n  startDrawing = (x, y) => {\n    this._isDrawing = true;\n    \n    this.attachListeners({\n      mouseMove: this.onMouseMove,\n      mouseUp: this.onMouseUp,\n      dblClick: this.onDblClick\n    });\n    \n    this.rubberband = new RubberbandFreehand([ x, y ], this.g, this.env);\n  }\n\n  stop = () => {\n    this.detachListeners();\n    \n    this._isDrawing = false;\n\n    if (this.rubberband) {\n      this.rubberband.destroy();\n      this.rubberband = null;\n    }\n  }\n\n  onMouseMove = (x, y) =>\n    this.rubberband.dragTo([ x, y ]);\n\n  onMouseUp = (x, y) => {\n    this.onDblClick(x, y);\n  }\n\n  onDblClick = (x, y) => {\n    this._isDrawing = false;\n\n    this.rubberband.addPoint([ x, y ]);\n\n    this.detachListeners();\n\n    const { width, height } = this.rubberband.getBoundingClientRect();\n\n    const minWidth = this.config.minSelectionWidth || 4;\n    const minHeight = this.config.minSelectionHeight || 4;\n\n    if (width >= minWidth || height >= minHeight) {\n\n      const shape = this.rubberband.element;\n      shape.annotation = this.rubberband.toSelection();\n\n      this.emit('complete', shape);\n    } else {\n      this.emit('cancel');\n    }\n\n    this.stop();\n  }\n\n  get isDrawing() {\n    return this._isDrawing;\n  }\n\n  createEditableShape = annotation =>\n    new EditableFreehand(annotation, this.g, this.config, this.env);\n\n}\n\nRubberbandFreehandTool.identifier = 'freehand';\n\nRubberbandFreehandTool.supports = annotation => {\n  const selector = annotation.selector('SvgSelector');\n  if (selector)\n    return (selector.value?.match(/^<svg.*<path*/g) && !selector.value.toUpperCase().includes(\"Z\"));\n}","import { Selection } from '@recogito/annotorious/src/tools/Tool';\nimport { toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\n//import Mask from './MultipolygonMask';\n// TODO optional: mask to dim the outside area\n//import Mask from './multipolygonMask';\n\n/**\n * A 'rubberband' selection tool for creating multipolygon drawing by\n * clicking and dragging.\n */\nexport default class RubberbandMultipolygon {\n\n  constructor(anchor, g, env) {\n    this.points = [];\n    this.points.push([ anchor, anchor ])\n\n    this.env = env;\n\n    this.group = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.multipolygon = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.multipolygon.setAttribute('class', 'a9s-selection');\n\n    this.outer = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.outer.setAttribute('class', 'a9s-outer');\n\n    this.inner = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.inner.setAttribute('class', 'a9s-inner');\n\n    this.setPoints(this.points);\n    //this.mask = new Mask(env.image, this.inner);\n\n   // TODO optional: mask to dim the outside area\n   // this.mask = new Mask(env.image, this.inner);\n\n    this.multipolygon.appendChild(this.outer);\n    this.multipolygon.appendChild(this.inner);\n\n    // Additionally, selection remains hidden until \n    // the user actually moves the mouse\n    this.group.style.display = 'none';\n\n    // TODO optional: mask to dim the outside area\n    // this.group.appendChild(this.mask.element);\n    //this.group.appendChild(this.mask.element);\n    this.group.appendChild(this.multipolygon);\n\n    g.appendChild(this.group);\n  }\n\n  setPoints = points => {\n    var attr =\"\";\n    for (var ps of points){\n      var attr2=\"\"\n      if (ps.length>0){\n        for (var p of ps) {\n          if (p){\n            if (attr2===\"\"){\n              attr2  +=`M${p[0]},${p[1]}`;\n            }\n            else{\n              attr2  +=` L${p[0]},${p[1]}`;\n            }\n          }\n        };\n         attr+=attr2\n      }\n    }\n    attr+=\" Z\"\n    this.outer.setAttribute('d', attr);\n    this.inner.setAttribute('d', attr);\n  }\n\n  getBoundingClientRect = () =>{\n    console.log(\"getBoundingClientRect\", this.outer);\n    this.outer.getBoundingClientRect();\n  }\n    dragTo = xy => {\n      // Make visible\n      this.group.style.display = null;\n      const head = this.points[this.points.length - 1].slice(0, this.points[this.points.length - 1].length - 1);\n      var headRest=this.points.slice(0,-1)\n      const rubberband = [ ...head, xy, head[0] ];\n      headRest.push(rubberband)\n      this.setPoints(headRest);\n      //this.mask.redraw();\n    }\n  \n  addPoint = xy => {\n    // Don't add a new point if distance < 2 pixels\n    // console.log(\"Entering addpoint\", this.points[this.points.length - 1].length);\n    if (this.points[this.points.length - 1].length>0){\n      const head = this.points[this.points.length - 1].slice(0, this.points[this.points.length - 1].length - 1);\n      const lastCorner = head[head.length - 1];\n      const dist = Math.pow(xy[0] - lastCorner[0], 2) + Math.pow(xy[1] - lastCorner[1], 2);\n      if (dist > 4) {\n        this.points[this.points.length - 1] = [ ...head, xy, head[0] ];\n        this.setPoints(this.points);   \n        //this.mask.redraw();\n      } \n    } else{\n      this.points[this.points.length - 1] = [xy,xy];\n      // console.log(this.points[this.points.length - 1]);\n      this.setPoints(this.points);\n    }\n  }\n  undo = () => {\n    console.log(\"last\",this.points[this.points.length - 1].length);\n    if (this.points[this.points.length - 1].length>2){\n      this.points[this.points.length - 1].pop();\n    } else {\n      if (this.points.length>1){\n        this.points.pop()\n      }\n    }\n  }\n  newPart = () => {\n    // console.log(\"NewPart triggered\");\n    this.points.push([]);\n    // console.log(\"points after newPart: \", this.points);\n  }\n \n  get element() {\n    return this.multipolygon;\n  }\n\n  destroy = () => {\n    this.group.parentNode.removeChild(this.group);\n    this.multipolygon = null;    \n    this.group = null;\n  }\n\n  toSelection = () => {\n    return new Selection(toSVGTarget(this.group, this.env.image));\n  }\n\n}\n","import EditableShape from '@recogito/annotorious/src/tools/EditableShape';\nimport { svgFragmentToShape, toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\nimport { format, setFormatterElSize } from '@recogito/annotorious/src/util/Formatting';\n\n// TODO optional: mask to dim the outside area\n//import Mask from './MultipolygonMask';\n\nconst getPoints = (shape) => {\n  // Could just be Array.from(shape.querySelector('.inner').points) but...\n  // IE11 :-(\n  const pointLists = getPointsFromPathValue(shape.querySelector('.a9s-inner').attributes.d.nodeValue)\n  const pointArray = [];\n  for (let pointList of pointLists) {\n    let points = []\n    for (let point of pointList) {\n      let p = {\n        x:parseFloat(point[0]),\n        y:parseFloat(point[1])\n      }\n      points.push(p);\n    }\n    pointArray.push(points);\n  }\n\n  return pointArray;\n}\nconst getPointsFromPathValue = polygon => {\n  var results =polygon.split('M');\n  var allcoords = []\n  results.forEach(function (result, index) {\n    if (result.length>0){\n      let coords = []\n      result=result.replace(/ Z/g,\"Z\")\n      result=result.replace(/Z /g,\"Z\")\n      result=result.replace(/Z/g,\"\")\n      result=result.replace(/L /g,\"L\")\n      result=result.replace(/ L/g,\"L\")\n      var coordsString = result.split(\"L\")\n      coordsString.forEach(function(coord, index){\n        coords.push([parseFloat(coord.split(\",\")[0]).toFixed(2).toString(),parseFloat(coord.split(\",\")[1]).toFixed(2).toString()]);\n      });\n      if (coords[0] !== coords[coords.length - 1]){\n        coords.push(coords[0])\n      }\n      allcoords.push(coords)\n    }\n  });\n  return allcoords\n}\nconst getBBox = shape => {\n  return shape.querySelector('.a9s-inner').getBBox();\n}\nexport const svgFragmentToPoints = annotation => {\n  const svgShape = svgFragmentToShape(annotation);\n  var polygon = svgShape.getAttribute('d')\n  var allcoords =  getPointsFromPathValue(polygon)\n  return allcoords\n  //svgShape.getAttribute('d')\n  //  .split(' ') // Split x/y tuples\n  //  .map(xy => xy.split(',').map(str => parseFloat(str.trim())));\n}\n\nconst drawEmbeddedSVG = annotation => {\n  const shape = svgFragmentToShape(annotation);\n\n  // Hack\n  svgFragmentToPoints(annotation);\n\n  // Because we're nitpicky, we don't just draw the shape,\n  // but duplicate it, so we can have inner and an outer lines\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n\n  const inner = shape.cloneNode(true);\n  inner.setAttribute('class', 'a9s-inner');\n\n  const outer = shape.cloneNode(true);\n  outer.setAttribute('class', 'a9s-outer');\n\n  g.appendChild(outer);\n  g.appendChild(inner);\n\n  return g;\n}\n/**\n * An editable multipolygon drawing.\n */\nexport default class EditableMultipolygon extends EditableShape {\n\n  constructor(annotation, g, config, env) {\n    super(annotation, g, config, env);\n\n    this.svg.addEventListener('mousemove', this.onMouseMove);\n    this.svg.addEventListener('mouseup', this.onMouseUp);\n\n    // SVG markup for this class looks like this:\n    // \n    // <g>\n    //   <path class=\"a9s-selection mask\"... />\n    //   <g> <-- return this node as .element\n    //     <polygon class=\"a9s-outer\" ... />\n    //     <polygon class=\"a9s-inner\" ... />\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     <g class=\"a9s-handle\" ...> ... </g>\n    //     ...\n    //   </g> \n    // </g>\n\n    // 'g' for the editable free drawing compound shape\n    this.containerGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    this.shape = drawEmbeddedSVG(annotation);\n   // TODO optional: mask to dim the outside area\n   // this.mask = new Mask(env.image, this.shape.querySelector('.a9s-inner'));\n    \n   // this.containerGroup.appendChild(this.mask.element);\n\n    this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');\n    this.elementGroup.appendChild(this.shape);\n    let pointList = getPoints(this.shape);\n    this.handles = []\n    for (let points of pointList){\n      this.handles.push(points.map(pt => {\n        const handle = this.drawHandle(pt.x, pt.y);\n        handle.addEventListener('mousedown', this.onGrab(handle));\n        this.elementGroup.appendChild(handle);\n        return handle;\n      }))\n    } \n\n\n    this.containerGroup.appendChild(this.elementGroup);\n    g.appendChild(this.containerGroup);\n\n    format(this.shape, annotation, config.formatter);\n\n    this.shape.querySelector('.a9s-inner')\n      .addEventListener('mousedown', this.onGrab(this.shape));\n\n    const { x, y, width, height } = getBBox(this.shape);\n\n    // TODO optional: handles to stretch the shape\n/*    this.handles = [\n      [ x, y ], \n      [ x + width, y ], \n      [ x + width, y + height ], \n      [ x, y + height ]\n    ].map(t => { \n      const [ x, y ] = t;\n      const handle = this.drawHandle(x, y);\n      handle.addEventListener('mousedown', this.onGrab(handle));\n      this.elementGroup.appendChild(handle);\n      return handle;\n    });*/\n\n    // The grabbed element (handle or entire shape), if any\n    this.grabbedElem = null;\n\n    // Mouse grab point\n    this.grabbedAt = null;\n  }\n\n  setPoints = (points) => {\n    const round = num =>\n    Math.round(10 * num) / 10;\n\n    let str = \"\"\n    for (let pointList of points){\n      str += \"M\"\n      let first = true \n      for (let point of pointList){\n        if (first){\n          first = false\n          str += point.x.toString() + \",\" + point.y.toString()\n        } else {\n          str += \" L\" + round(point.x).toString() + \",\" + round(point.y).toString()\n        }\n      }\n      str += \" Z\"\n    }\n    const inner = this.shape.querySelector('.a9s-inner');\n    inner.setAttribute('d', str);\n\n    const outer = this.shape.querySelector('.a9s-outer');\n    outer.setAttribute('d', str);\n\n    // this.mask.redraw();\n\n    const { x, y, width, height } = outer.getBBox();\n    setFormatterElSize(this.elementGroup, x, y, width, height);\n  }\n\n\n    // TODO optional: handles to stretch the shape\n/*  stretchCorners = (draggedHandleIdx, anchorHandle, mousePos) => {\n    const anchor = this.getHandleXY(anchorHandle);\n  }*/\n\n  onGrab = grabbedElem => evt => {\n    this.grabbedElem = grabbedElem;\n    const pos = this.getSVGPoint(evt);\n    this.grabbedAt = { x: pos.x, y: pos.y };\n  }\n\n  onMouseMove = evt => {\n    if (this.grabbedElem) {\n\n      const pos = this.getSVGPoint(evt);\n\n      if (this.grabbedElem === this.shape) {\n        const dx = pos.x - this.grabbedAt.x;\n        const dy = pos.y - this.grabbedAt.y;\n\n        let pointList = getPoints(this.shape)\n\n        const updatedPoints = []\n        for (let points of pointList){\n          updatedPoints.push(points.map(pt =>\n            ({ x: pt.x + dx, y: pt.y + dy })))\n        } \n    \n        this.grabbedAt = pos;\n\n        this.setPoints(updatedPoints);\n        let i = 0\n        for (let updatedPointsList of updatedPoints){\n            updatedPointsList.forEach((pt, idx) => { \n              if (this.handles[i][idx] !== undefined)\n                this.setHandleXY(this.handles[i][idx], pt.x, pt.y)\n            });\n            i+=1\n        }\n        \n        this.emit('update', {\n          ...toSVGTarget(this.shape, this.env.image),\n          renderedVia: {\n            name: 'multipolygon'\n          }\n        });\n      } else {\n        let handleIdx = -1\n        let pointListIDX = 0\n        let found = false\n\n        for (let handle of this.handles){\n          if (handle.indexOf(this.grabbedElem)>0){\n            handleIdx = handle.indexOf(this.grabbedElem);\n            found=true\n          } else {\n            if (!found){\n              pointListIDX += 1\n            }\n          }\n        }\n  \n        let pointList = getPoints(this.shape)\n  \n        const updatedPoints = []\n        let updatedPointsIDX = 0\n        for (let points of pointList){\n          if (updatedPointsIDX === pointListIDX){\n            let newPoints = []\n            points.forEach(function (value, i) {\n              if (i === handleIdx){\n                newPoints.push(pos)\n              } else {\n                newPoints.push(value)\n              }\n            });\n            updatedPoints.push(newPoints)\n          } else {\n            updatedPoints.push(points)\n          }\n          updatedPointsIDX +=1\n        } \n       \n        this.setPoints(updatedPoints);\n        updatedPointsIDX = 0\n        for (let handle of this.handles){\n          if (updatedPointsIDX === pointListIDX){\n\n            this.setHandleXY(handle[handleIdx], pos.x, pos.y);\n          }\n          updatedPointsIDX +=1\n\n        }\n        \n        this.emit('update', {\n          ...toSVGTarget(this.shape, this.env.image),\n          renderedVia: {\n            name: 'multipolygon'\n          }\n        });\n      }\n    }\n  }\n\n  onMouseUp = evt => {\n    this.grabbedElem = null;\n    this.grabbedAt = null;\n  }\n\n  get element() {\n    return this.elementGroup;\n  }\n\n  updateState = annotation => {\n    const points = getPoints(svgFragmentToShape(annotation));\n    this.setPoints(points);\n  }\n\n  destroy = () => {\n    this.containerGroup.parentNode.removeChild(this.containerGroup);\n    super.destroy();\n  }\n\n}","import Tool from '@recogito/annotorious/src/tools/Tool';\nimport RubberbandMultipolygon from './RubberbandMultipolygon';\nimport EditableMultipolygon from './EditableMultipolygon';\n\n/**\n * A rubberband selector for Multipolygon fragments.\n */\nexport default class RubberbandMultipolygonTool extends Tool {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n    this._isDrawing = false;\n    document.addEventListener('keydown', evt => {\n      //console.log(\"keyDown Driggered\",evt);\n      if (evt.key == \"z\" && evt.ctrlKey) {\n        // console.log(\"doing undo\");\n        this.undo();\n      }\n      if (evt.key == 'n') {\n        //console.log(\"n recognized\");\n        this.newPart();\n      }\n    });  }\n\n  startDrawing = (x, y) => {\n    this._isDrawing = true;\n    \n    this.attachListeners({\n      mouseMove: this.onMouseMove,\n      mouseUp: this.onMouseUp,\n      dblClick: this.onDblClick\n    });\n    \n    this.rubberband = new RubberbandMultipolygon([ x, y ], this.g, this.env);\n  }\n\n  stop = () => {\n    this.detachListeners();\n    \n    this._isDrawing = false;\n\n    if (this.rubberband) {\n      this.rubberband.destroy();\n      this.rubberband = null;\n    }\n  }\n  undo = () =>{\n    // console.log(\"rubberband undo\",this.rubberband);\n    if (this.rubberband){\n      this.rubberband.undo();\n\n    }\n    //console.log(this);\n  }\n  newPart = () =>{\n    if (this.rubberband){\n      this.rubberband.newPart();\n\n    }\n    //console.log(this);\n  }\n\n  onMouseMove = (x, y) =>\n    this.rubberband.dragTo([ x, y ]);\n\n  onMouseUp = (x, y, evt) => {\n    if (evt.altKey){\n      this.onDblClick(evt);\n    } else if (evt.ctrlKey) {\n      this.rubberband.undo();\n    } else{\n      const { width, height } = this.rubberband.getBoundingClientRect();\n\n      const minWidth = this.config.minSelectionWidth || 4;\n      const minHeight = this.config.minSelectionHeight || 4;\n      \n      if (width >= minWidth || height >= minHeight) {\n        this.rubberband.addPoint([ x, y ]);\n      } else {\n        this.emit('cancel');\n        this.stop();\n      }\n    }\n  }\n  \n  onDblClick = (x, y) => {\n    this._isDrawing = false;\n\n    this.rubberband.addPoint([ x, y ]);\n\n    const shape = this.rubberband.element;\n    shape.annotation = this.rubberband.toSelection();\n    this.emit('complete', shape);\n\n    this.stop();\n  }\n\n  get isDrawing() {\n    return this._isDrawing;\n  }\n\n  get isDrawing() {\n    return this._isDrawing;\n  }\n\n  createEditableShape = annotation => \n    new EditableMultipolygon(annotation, this.g, this.config, this.env);\n\n}\n\nRubberbandMultipolygonTool.identifier = 'multipolygon';\n\nRubberbandMultipolygonTool.supports = annotation => {\n  console.log(\"supports started\");\n  const selector = annotation.selector('SvgSelector');\n  console.log(\"selector\", selector);\n  console.log(selector.value?.match(/^<svg.*<path d=/g))\n  if (selector)\n    return selector.value?.match(/^<svg.*<path d=/g);\n}","import { Selection, ToolLike } from '@recogito/annotorious/src/tools/Tool';\nimport { toSVGTarget } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { SVG_NAMESPACE } from '@recogito/annotorious/src/util/SVG';\n//import Mask from './MultipolygonMask';\n// TODO optional: mask to dim the outside area\n//import Mask from './multipolygonMask';\n\n/**\n * A 'rubberband' selection tool for creating multipolygon drawing by\n * clicking and dragging.\n */\nexport default class RubberbandBetterMultipolygon extends ToolLike  {\n\n  constructor(anchor, g, config, env) {\n    super(g, config, env);\n    //super(g, config, env);\n    this.points = [];\n    this.points.push([ anchor, anchor ])\n    this.mousepos = anchor;\n\n    this.env = env;\n    this.scale = 1;\n\n    this.group = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.multipolygon = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.multipolygon.setAttribute('class', 'a9s-selection a9s-multipolygon improved-polygon');\n\n    this.rubberband = document.createElementNS(SVG_NAMESPACE, 'polygon');\n    this.rubberband.setAttribute('class', 'a9s-rubberband');\n\n    this.closeHandle = this.drawHandle(anchor[0], anchor[1]);\n    this.closeHandle.style.display = 'none';\n\n    this.outer = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.outer.setAttribute('class', 'a9s-outer');\n\n    this.inner = document.createElementNS(SVG_NAMESPACE, 'path');\n    this.inner.setAttribute('class', 'a9s-inner');\n\n    this.setPoints(this.points);\n    //this.mask = new Mask(env.image, this.inner);\n\n   // TODO optional: mask to dim the outside area\n   // this.mask = new Mask(env.image, this.inner);\n\n   this.multipolygon.appendChild(this.rubberband)\n   this.multipolygon.appendChild(this.outer);\n   this.multipolygon.appendChild(this.inner);\n   this.multipolygon.appendChild(this.closeHandle);\n\n    // Additionally, selection remains hidden until \n    // the user actually moves the mouse\n    this.group.style.display = 'none';\n\n    // TODO optional: mask to dim the outside area\n    // this.group.appendChild(this.mask.element);\n    //this.group.appendChild(this.mask.element);\n    this.group.appendChild(this.multipolygon);\n\n    g.appendChild(this.group);\n  }\n\n  setPoints = points => {\n    var attr =\"\";\n    for (var ps of points){\n      var attr2=\"\"\n      if (ps.length>0){\n        for (var p of ps) {\n          if (p){\n            if (attr2===\"\"){\n              attr2  +=`M${p[0]},${p[1]}`;\n            }\n            else{\n              attr2  +=` L${p[0]},${p[1]}`;\n            }\n          }\n        };\n         attr+=attr2\n      }\n    }\n    attr+=\" Z\"\n    this.outer.setAttribute('d', attr);\n    this.inner.setAttribute('d', attr);\n  }\n  close = () => {\n    const multipolygon = new multipolygon(toSVGTarget(this.points, this.env.image));\n    this.emit('close', { shape: this.multipolygon, multipolygon });\n  }\n\n  getBoundingClientRect = () => {\n     return this.outer.getBoundingClientRect();\n  }\n\n  dragTo = xy => {\n    // Make visible\n    this.group.style.display = null;\n    this.mousepos = xy;\n    const head = this.points[this.points.length - 1].slice(0, this.points[this.points.length - 1].length - 1);\n    var headRest=this.points.slice(0,-1)\n    const rubberband = [ ...head, xy, head[0] ];\n    headRest.push(rubberband)\n    this.setPoints(headRest);\n    //this.mask.redraw();\n  }\n  onScaleChanged = scale => {\n    this.scale = scale;\n\n    const inner = this.closeHandle.querySelector('.a9s-handle-inner');\n    const outer = this.closeHandle.querySelector('.a9s-handle-outer');\n\n    const radius = scale * (this.config.handleRadius || 6);\n\n    inner.setAttribute('r', radius);\n    outer.setAttribute('r', radius);\n  }\n    \n  addPoint = xy => {\n    // Don't add a new point if distance < 2 pixels\n    if (this.isClosable()) {\n      // Close, don't add\n      this.close();\n    } else {\n      if (this.points[this.points.length - 1].length>0){\n        const head = this.points[this.points.length - 1].slice(0, this.points[this.points.length - 1].length - 1);\n        const lastCorner = head[head.length - 1];\n        const dist = Math.pow(xy[0] - lastCorner[0], 2) + Math.pow(xy[1] - lastCorner[1], 2);\n        if (dist > 4) {\n          this.points[this.points.length - 1] = [ ...head, xy, head[0] ];\n          this.setPoints(this.points);   \n          //this.mask.redraw();\n        } \n      } else{\n        this.points[this.points.length - 1] = [xy,xy];\n        this.setPoints(this.points);\n      }\n    }\n  }\n  undo = () => {\n    this.pop()\n  }\n\n  isClosable = () => {\n    const d = this.getDistanceToStart();\n    return d < 6 * this.scale;\n  }\n  /** Removes last corner **/\n  pop = () => {\n    if (this.points[this.points.length - 1].length>2){\n      this.points[this.points.length - 1].pop();\n    } else {\n      if (this.points.length>1){\n        this.points.pop()\n      }\n    }\n    this.setPoints(this.points);\n    this.mask.redraw();\n  }\n\n  newPart = () => {\n    this.points.push([]);\n  }\n \n  get element() {\n    return this.multipolygon;\n  }\n  getDistanceToStart = () => {\n    if (this.points[this.points.length-1].length < 3)\n      return Infinity; // Just return if not at least 3 points\n\n    const dx = Math.abs(this.mousepos[0] - this.points[this.points.length-1][0][0]);\n    const dy = Math.abs(this.mousepos[1] - this.points[this.points.length-1][0][1]);\n\n    return Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2)) / this.scale;\n  }\n\n  destroy = () => {\n    this.group.parentNode.removeChild(this.group);\n    this.multipolygon = null;    \n    this.group = null;\n  }\n  toSelection = () => {\n    return new Selection(toSVGTarget(this.group, this.env.image));\n  }\n\n}\n","/**\n * Computes the area of the polygon defined by\n * the given conrner points.\n * @param {Array} points \n * @returns {number} the area\n */\nexport const polygonArea = points => {\n  let area = 0;\n  let j = points.length - 1;\n\n  for (let i=0; i < points.length; i++) {\n    area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n    j = i;\n  }\n\n  return Math.abs(0.5 * area);\n}\n\n/**\n * Hit test: checks if this point is inside the circle.\n * @param {Array} point the point [x, y]\n * @param {number} cx circle center x\n * @param {number} cy circle center y\n * @param {number} r circle radius\n * @returns {boolean} \n */\nexport const pointInCircle = (point, cx, cy, r) => {\n  const dx = point[0] - cx;\n  const dy = point[1] - cy;\n\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= r;\n}\n\n/**\n * Hit test: checks if this point is inside the ellipse.\n * Cf. https://github.com/w8r/point-in-ellipse\n * @param {Array} point the point [x, y] \n * @param {number} cx ellipse center x \n * @param {number} cy ellipse center y\n * @param {number} rx ellipse x radius\n * @param {number} ry ellipse y radius\n * @param {number=} rotation ellipse rotation \n * @returns {boolean}\n */\nexport const pointInEllipse = (point, cx, cy, rx, ry, rotation) => {\n  const rot = rotation || 0;\n\n  const cos = Math.cos(rot);\n  const sin = Math.sin(rot);\n\n  const dx  = point[0] - cx;\n  const dy  = point[1] - cy;\n\n  const tdx = cos * dx + sin * dy;\n  const tdy = sin * dx - cos * dy;\n\n  return (tdx * tdx) / (rx * rx) + (tdy * tdy) / (ry * ry) <= 1;\n}\n\n/**\n * Hit test: checks if this point is inside the polygon.\n * @param {Array} xy the point [x, y]\n * @param {Array<number>} points polygon corner points \n * @returns {boolean}\n */\nexport const pointInsidePoygon = (point, polygon) => {\n  \n  var n=polygon.length,\n  is_in=false,\n  x=point[0],\n  y=point[1],\n  x1,x2,y1,y2;\n\nfor(var i=0; i < n-1; ++i){\n  x1=polygon[i][0];\n  x2=polygon[i+1][0];\n  y1=polygon[i][1];\n  y2=polygon[i+1][1];\n\n  if(y < y1 != y < y2 && x < (x2-x1) * (y-y1) / (y2-y1) + x1){\n      is_in=!is_in;\n  }\n}\n\nreturn is_in;\n};\n\nexport const isHole = (polygon1, polygon2) => {\n  // Algorithm checks, if polygon1 is in polygon2\n  for (var point of polygon1){\n    if (!pointInPolygon(point, polygon2)) return false\n  }\n  return true;\n}\n\nexport const pointInPolygon = (point, polygon) => {\n\n  var n=polygon.length,\n  is_in=false,\n  x=point[0],\n  y=point[1],\n  x1,x2,y1,y2;\n\n  for(var i=0; i < n-1; ++i){\n    x1=polygon[i][0];point\n    x2=polygon[i+1][0];\n    y1=polygon[i][1];\n    y2=polygon[i+1][1];\n\n    if(y < y1 != y < y2 && x < (x2-x1) * (y-y1) / (y2-y1) + x1){\n        is_in=!is_in;\n    }\n  }\n  return is_in;\n};\n\n\n/**\n * Checks if polygon A is contained fully inside polygon B.\n * @param {Array<Array<number>>} polygonA array of points [x, y] \n * @param {Array<Array<number>>} polygonB array of points [x, y]\n * @returns {boolean}\n */\nexport const polygonInPolygon = (polygonA, polygonB) => {\n  for (let point of polygonA) {\n    if (!pointInPolygon(point, polygonB)) \n      return false\n  }\n\n  return true;\n}\n\n/** \n * Hit test: checks if this point is inside the line.\n * @param {Array} xy the point [x, y]\n * @param number x1 line start x\n * @param number y1 line start y\n * @param number x2 line end x\n * @param number y2 line end y\n * @param number buffer around the line\n * @returns {boolean}\n */\nexport const pointInLine = (xy, x1, y1, x2, y2, buffer) => {\n  const x = xy[0];\n  const y = xy[1];\n\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  const cross = Math.abs((x - x1) * dy - (y - y1) * dx);\n  const dist = cross / d;\n\n  return dist <= buffer;\n}\n\n/**\n * A utility helper that parses an SVG path into \n * a list of polygons.\n * @param {SVGElement} path the SVG path\n * @returns {Array<Array<Array<number>>>} list of polygons \n */\nexport const svgPathToPolygons = path => {\n  const commands = path.getAttribute('d')\n    .split(/(?=M|m|L|l|H|h|V|v|Z|z)/g)\n    .map(str => str.trim());\n  const polygons = [];\n\n  let points = [];\n\n  for (let cmd of commands) {\n    const op = cmd.substring(0, 1);\n    let xy\n    if (op.toLowerCase() === 'z') {\n      polygons.push([...points]);\n      points = [];\n    } else {\n      if (cmd.includes(\",\")){\n        xy = cmd.substring(1).split(',').map(str => parseFloat(str.trim()));\n      } else {\n        xy = cmd.substring(1).split(' ').map(str => parseFloat(str.trim()));\n\n      }\n      // Uppercase ops are absolute coords -> transform\n      const isUppercase = op === op.toUpperCase();\n\n      const x = isUppercase ? xy[0] : xy[0] + points[points.length - 1][0];\n      const y = isUppercase ? xy[1] : xy[1] + points[points.length - 1][1];\n\n      points.push([x, y]);\n    }\n  }\n\n  if (points.length > 0) // Unclosed path - close for area computation\n    polygons.push([...points]); \n  return polygons;\n}","import EditableShape from '@recogito/annotorious/src/tools/EditableShape';\nimport { SVG_NAMESPACE, addClass, hasClass, removeClass } from '@recogito/annotorious/src/util/SVG';\nimport { format, setFormatterElSize } from '@recogito/annotorious/src/util/Formatting';\nimport { svgFragmentToShape } from '@recogito/annotorious/src/selectors/EmbeddedSVG';\nimport { pointInPolygon } from '@recogito/annotorious/src/util/Geom2D';\nimport RubberbandBetterMultipolygon from './RubberbandBetterMultipolygon';\n\nimport { toSVGTarget, getPath } from './RubberbandBetterMultipolygonTool';\n\nconst getPointsFromPathValue = polygon => {\n  var results =polygon.split('M');\n  var allcoords = []\n  results.forEach(function (result, index) {\n    if (result.length>0){\n      let coords = []\n      result=result.replace(/ Z/g,\"Z\")\n      result=result.replace(/Z /g,\"Z\")\n      result=result.replace(/Z/g,\"\")\n      result=result.replace(/L /g,\"L\")\n      result=result.replace(/ L/g,\"L\")\n      var coordsString = result.split(\"L\")\n      coordsString.forEach(function(coord, index){\n        coords.push([parseFloat(coord.split(\",\")[0]).toFixed(2).toString(),parseFloat(coord.split(\",\")[1]).toFixed(2).toString()]);\n      });\n      if (coords[0][0] !== coords[coords.length - 1][0] && coords[0][1] !== coords[coords.length - 1][1]){\n        coords.push(coords[0])\n      }\n      allcoords.push(coords)\n    }\n  });\n  return allcoords\n}\n\n\nconst getPoints = (shape) => {\n  // Could just be Array.from(shape.querySelector('.inner').points) but...\n  // IE11 :-(\n  const pointLists = getPointsFromPathValue(shape.querySelector('.a9s-inner').attributes.d.nodeValue)\n  const pointArray = [];\n  for (let pointList of pointLists) {\n    let points = []\n    for (let point of pointList) {\n      let p = {\n        x:parseFloat(point[0]),\n        y:parseFloat(point[1])\n      }\n      points.push(p);\n    }\n    pointArray.push(points)\n  }\n  return pointArray;\n}\n\nconst getBBox = shape => {\n  return shape.querySelector('.a9s-inner').getBBox();\n}\nexport const svgFragmentToPoints = annotation => {\n  const svgShape = svgFragmentToShape(annotation);\n  var polygon = svgShape.getAttribute('d')\n  var allcoords =  getPointsFromPathValue(polygon)\n  return allcoords\n}\n\nconst drawEmbeddedSVG = annotation => {\n  const shape = svgFragmentToShape(annotation);\n  // Hack\n  svgFragmentToPoints(annotation);\n\n  // Because we're nitpicky, we don't just draw the shape,\n  // but duplicate it, so we can have inner and an outer lines\n  const g = document.createElementNS(SVG_NAMESPACE, 'g');\n\n  const inner = shape.cloneNode(true);\n  inner.setAttribute('class', 'a9s-inner');\n\n  const outer = shape.cloneNode(true);\n  outer.setAttribute('class', 'a9s-outer');\n\n  g.appendChild(outer);\n  g.appendChild(inner);\n  return g;\n}\n  \nexport default class EditableBetterMultipolygon extends EditableShape {\n\n  constructor(annotation, g, config, env) {\n    super(annotation, g, config, env);\n\n    this.svg.addEventListener('mousemove', this.onMouseMove);\n    this.svg.addEventListener('mouseup', this.onMouseUp);\n\n    document.body.addEventListener('keydown', this.onKeyDown);\n\n    // Container wraps the mask + editable shape\n    this.container = document.createElementNS(SVG_NAMESPACE, 'g');\n\n    // The editable shape group\n    this.shape = drawEmbeddedSVG(annotation);\n    this.shape.setAttribute('class', 'a9s-annotation editable selected improved-polygon');\n    this.elementGroup = document.createElementNS(SVG_NAMESPACE, 'g');\n    this.elementGroup.setAttribute('class', 'a9s-annotation editable selected');\n    this.elementGroup.appendChild(this.shape);\n    let cornerList = getPoints(this.shape);\n    this.cornerHandles = []\n    this.midpoints = []\n    for (let corners of cornerList){\n      let midpoints = []\n      this.cornerHandles.push(corners.map((pt, idx) => {\n        midpoints.push(this.createMidpoint(corners, idx));\n        const handle = this.createCornerHandle(pt);\n        // Midpoint handles\n        return handle;\n      }))\n      this.midpoints.push(midpoints);\n    }\n    this.container.appendChild(this.elementGroup)\n    g.appendChild(this.container);\n    // Format needs to go after everything is added to the DOM\n    format(this.shape, annotation, config.formatter);\n    this.shape.querySelector('.a9s-inner')\n      .addEventListener('mousedown', this.onGrab(this.shape));\n\n    // Grabbed element and grab offset\n    this.grabbedElement = null;\n    this.grabbedAt = null;\n\n    // Selected corners\n    this.selected = [];\n\n    this.lastMouseDown = null;\n  }\n\n  createCornerHandle = pt => {\n    const handle = this.drawHandle(pt.x, pt.y);\n    handle.addEventListener('mousedown', this.onGrab(handle));\n    handle.addEventListener('click', this.onSelectCorner(handle));\n    this.scaleHandle(handle);\n\n    this.elementGroup.appendChild(handle);\n    return handle;\n  }\n\n  createMidpoint = (corners, idx) => {\n    // Create point between this and previous corner\n    const thisCorner = corners[idx];\n    const nextCorner = idx === corners.length - 1 ? corners[0] : corners[idx + 1];\n    const x = (thisCorner.x + nextCorner.x) / 2;\n    const y = (thisCorner.y + nextCorner.y) / 2;\n    const handle = this.drawMidpoint(x, y);\n    handle.addEventListener('mousedown', this.onGrab(handle));\n\n    this.shape.appendChild(handle);\n    return handle;\n  }\n\n  deleteSelected = () => {\n    const points = getPoints(this.shape);\n    \n    if (this.selected.length > 0 ) {\n      let cornerhandlesIDX = -1\n      let updatedPoints = []\n      // Update midpoints\n      let newMidpoints = []\n      let midpointsToDelete = []\n      let midpointsIDX = -1\n      for (let midpointList of this.midpoints){\n        midpointsIDX += 1\n        let updatedMidpointlist = midpointList.filter((object, i) => {\n          return this.selected.map(object => (object[0] === cornerhandlesIDX && object[1] === i)).indexOf(true) === -1\n        });      \n        let midpointsToDelete = midpointList.filter((object, i) => {\n          return this.selected.map(object => (object[0] === cornerhandlesIDX && object[1] === i)).indexOf(true) > -1\n        });\n        midpointsToDelete.forEach(h => h.parentNode.removeChild(h));\n        if (updatedMidpointlist.length > 2){\n          newMidpoints.push(updatedMidpointlist)\n        }\n      }\n      for (let pointList of points){\n        cornerhandlesIDX += 1\n        let updatedPointlist = pointList.filter((object, i) => {\n          return this.selected.map(object => (object[0] === cornerhandlesIDX && object[1] === i)).indexOf(true) === -1\n        });\n        if (updatedPointlist.length > 2){\n          updatedPoints.push(updatedPointlist)\n        }\n      }\n      cornerhandlesIDX = -1\n      let updatedHandles = []\n      for (let handlesList of this.cornerHandles){\n        cornerhandlesIDX += 1\n        let handlesToDelete = handlesList.filter((object, i) => {\n          if (this.selected.map(object => (object[0] === cornerhandlesIDX && object[1] === i)).indexOf(true) !== -1){\n            return true\n          } else {\n            return false\n          } \n        });\n        let handlesToStay = handlesList.filter((object, i) => {\n          return this.selected.map(object => (object[0] === cornerhandlesIDX && object[1] === i)).indexOf(true) === -1\n        });\n        if (handlesToStay.length > 2){\n          updatedHandles.push(handlesToStay)\n        }\n        handlesToDelete.forEach(h => h.parentNode.removeChild(h));\n      }\n      this.midpoints = newMidpoints\n    // Update corner handles\n\n      this.cornerHandles = updatedHandles\n      this.selected = []\n\n      this.setPoints(updatedPoints);\n      this.emit('update', toSVGTarget(updatedPoints, this.env.image));\n    }\n  }\n\n  deselectCorners = () =>\n    this.cornerHandles.forEach(h => removeClass(h, 'selected'));\n\n  destroy = () => {\n    this.container.parentNode.removeChild(this.container);\n\n    this.svg.removeEventListener('mousemove', this.onMouseMove);\n    this.svg.removeEventListener('mouseup', this.onMouseUp);\n\n    document.body.removeEventListener('keydown', this.onKeyDown);\n\n    super.destroy();\n  }\n\n  drawMidpoint = (x, y) => {\n    const handle = document.createElementNS(SVG_NAMESPACE, 'circle');\n    handle.setAttribute('class', 'a9s-midpoint');\n    \n    handle.setAttribute('cx', x);\n    handle.setAttribute('cy', y);\n    handle.setAttribute('r', 5 * this.scale);\n\n    return handle;\n  }\n\n  get element() {\n    return this.elementGroup;\n  }\n\n  onAddPoint = pos => {\n    const corners = getPoints(this.shape);\n    let idx = -1\n    let midpointsIDX = -1\n    for (let midpointList of this.midpoints){\n      midpointsIDX += 1\n      idx = midpointList.indexOf(this.grabbedElement);\n      if (idx > -1){\n        break;\n      }\n    }\n    // Updated polygon points\n    let updatedCorners = []\n    let updatedcornerListIdx = -1\n    let midBefore = null\n    let midAfter = null\n    for (let cornerList of corners){\n      updatedcornerListIdx +=1\n      if (updatedcornerListIdx === midpointsIDX){\n        let updatedCornersList = []\n        let updatedcornerIdx = -1\n        for (let corner of cornerList){\n          updatedcornerIdx += 1\n          updatedCornersList.push(corner)     \n          if (updatedcornerIdx === idx){\n            updatedCornersList.push(pos)\n            midBefore = this.createMidpoint(cornerList, updatedcornerIdx -1);\n            midAfter = this.createMidpoint(cornerList, updatedcornerIdx);          \n          }\n        }\n        updatedCorners.push(updatedCornersList)\n      } else {\n        updatedCorners.push(cornerList)\n      }\n      \n    }\n\n    // New corner handle\n    const cornerHandle = this.createCornerHandle(pos);\n    this.cornerHandles[midpointsIDX] = [\n      ...this.cornerHandles[midpointsIDX].slice(0, idx+1),\n      cornerHandle,\n      ...this.cornerHandles[midpointsIDX].slice(idx+1)\n    ];\n    this.midpoints[midpointsIDX] = [\n      ...this.midpoints[midpointsIDX].slice(0, idx),\n      midBefore,\n      midAfter,\n      ...this.midpoints[midpointsIDX].slice(idx + 1)\n    ];\n    // Delete old midpoint\n    this.grabbedElement.parentNode.removeChild(this.grabbedElement);\n    \n    // Make the newly created corner dragged element + selection\n    this.grabbedElement = cornerHandle;\n    //this.onSelectCorner(cornerHandle)();\n\n    // Update shape\n    this.setPoints(updatedCorners);\n  }\n\n  onGrab = element => evt => {\n    if (evt.button !== 0) return;  // left click\n    evt.stopPropagation();\n\n    this.grabbedElement = element;\n    this.grabbedAt = this.getSVGPoint(evt);\n    this.lastMouseDown = new Date().getTime();\n  }\n\n  onKeyDown = ({ which }) => {\n    if (which === 46) {\n      this.deleteSelected();\n    }\n  }\n\n  onMoveShape = pos => {\n    const constrain = (coord, delta, max) =>\n      coord + delta < 0 ? -coord : (coord + delta > max ? max - coord : delta);\n    const { x, y, width, height } = getBBox(this.shape);\n    const { naturalWidth, naturalHeight } = this.env.image;\n\n    const dx = constrain(x, pos.x - this.grabbedAt.x, naturalWidth - width);\n    const dy = constrain(y, pos.y - this.grabbedAt.y, naturalHeight - height);\n    let updatedPoints = []\n    for (let pointlist of getPoints(this.shape)){\n      let newPointList = pointlist.map(pt => ([ pt.x , pt.y ]))\n      if (pointInPolygon([this.grabbedAt.x,this.grabbedAt.y], newPointList)){\n        updatedPoints.push(pointlist.map(pt =>\n          ({ x: pt.x + dx, y: pt.y + dy })))    \n      } else {\n        updatedPoints.push(pointlist)\n      }\n    }\n    this.grabbedAt = pos;\n\n    // Update shape\n    this.setPoints(updatedPoints);\n  }\n\n  onMoveCornerHandle = (pos, evt) => {\n    let handleIdx = -1\n    let cornerHandleIdx = 0\n    for (let cornerHandle of this.cornerHandles){\n      handleIdx = cornerHandle.indexOf(this.grabbedElement);\n      if (handleIdx > -1){ \n        break\n      } else {\n        cornerHandleIdx += 1\n      }\n    }\n    \n    // Update selection\n    if (evt.ctrlKey) {\n      this.selected = Array.from(new Set([...this.selected, handleIdx]));\n    } else if (!this.selected.includes(handleIdx)) {\n      this.selected = [ handleIdx ];\n    }\n\n    // Compute offsets between selected points from current selected\n    const points = getPoints(this.shape);\n\n    const distances = this.selected.map(idx => {\n      const handleXY = points[cornerHandleIdx][handleIdx];\n      const thisXY = points[cornerHandleIdx][idx];\n\n      return {\n        index: idx,\n        dx: thisXY.x - handleXY.x,\n        dy: thisXY.y - handleXY.y\n      }\n    });\n    let cornerHandleIdxUpdate = 0\n    let updatedPoints = []\n    for (let points of getPoints(this.shape)){\n      if (cornerHandleIdxUpdate === cornerHandleIdx){\n        let updatedPointList = points.map((pt, idx) => {\n          if (idx === handleIdx) {\n            // The dragged point\n            return pos;\n          } else if (this.selected.includes(idx)) {\n            const { dx, dy } = distances.find(d => d.index === idx);\n            return {\n              x: pos.x + dx,\n              y: pos.y + dy\n            }\n          } else {\n            // Unchanged\n            return pt;\n          }\n        });\n        updatedPoints.push(updatedPointList);\n      } else {\n        updatedPoints.push(points)\n      }\n      cornerHandleIdxUpdate += 1\n    }\n    this.setPoints(updatedPoints);\n  }\n\n  onMouseMove = evt => {\n    if (this.grabbedElement) {\n      const pos = this.getSVGPoint(evt);\n      if (this.grabbedElement === this.shape) {\n        this.onMoveShape(pos);\n      } else if (hasClass(this.grabbedElement, 'a9s-handle')) {\n        this.onMoveCornerHandle(pos, evt);\n      } else if (hasClass(this.grabbedElement, 'a9s-midpoint')) {\n        this.onAddPoint(pos);\n      }\n\n      this.emit('update', toSVGTarget(getPoints(this.shape), this.env.image));\n    }\n  }\n\n  onMouseUp = evt => {\n    this.grabbedElement = null;\n    this.grabbedAt = null;\n  }\n\n  onScaleChanged = scale => {\n    for (let cornerHandle of this.cornerHandles){\n      cornerHandle.map(this.scaleHandle);\n    }\n    for (let midpoints of this.midpoints){\n      midpoints.map(midpoint => {\n        midpoint.setAttribute('r', 5 * this.scale);\n      });\n    }\n  }\n\n  onSelectCorner = handle => evt => {\n    const isDrag = new Date().getTime() - this.lastMouseDown > 250;\n\n    if (!isDrag) {\n      let cornerhandlesIDX = -1\n      let idx = -1\n      for (let corners of this.cornerHandles){\n        cornerhandlesIDX += 1\n        idx = corners.indexOf(handle);  \n        if (idx > 0) break\n      }\n\n      if (evt?.ctrlKey) {\n        // Toggle\n        if ( this.selected.map(object => (object[0] === cornerhandlesIDX && object[1] === idx)).indexOf(true) > -1) {\n          this.selected = this.selected.filter(i => {\n            return !(i[1] === idx && i[0] === cornerhandlesIDX)\n          });\n        } else \n          this.selected = [...this.selected, [cornerhandlesIDX, idx]];\n      } else { \n        if (this.selected.length === 1 && (this.selected[0][1] === idx && this.selected[0][0] === cornerhandlesIDX)) {\n          this.selected = [];\n        } else {\n          this.selected = [[cornerhandlesIDX, idx ]];\n        }\n      }\n\n      this.setPoints(getPoints(this.shape));\n    }\n  }\n\n  setPoints = points => {\n    // Not using .toFixed(1) because that will ALWAYS\n    // Set polygon points\n    const str = getPath(points);\n    const inner = this.shape.querySelector('.a9s-inner');\n    inner.setAttribute('d', str);\n\n    const outer = this.shape.querySelector('.a9s-outer');\n    outer.setAttribute('d', str);\n\n    // Corner handles\n    let cornerIdx = 0\n    for (let pointList of points){\n      pointList.forEach((pt, idx) => {\n        this.setHandleXY(this.cornerHandles[cornerIdx][idx], pt.x, pt.y)\n      });\n    // Midpoints\n      for (let idx=0; idx<pointList.length; idx++) {\n        const thisCorner = pointList[idx];\n        const nextCorner = idx === pointList.length - 1 ? pointList[0] : pointList[idx + 1];\n        const x = (thisCorner.x + nextCorner.x) / 2;\n        const y = (thisCorner.y + nextCorner.y) / 2;\n\n        const handle = this.midpoints[cornerIdx][idx];\n        handle.setAttribute('cx', x);\n        handle.setAttribute('cy', y);\n      }\n        cornerIdx +=1\n    }\n    let cornerHandleIdx = -1\n    for (let corners of this.cornerHandles){\n      cornerHandleIdx += 1\n\n      corners.forEach((handle, i) => {\n        \n        const isSelected = this.selected.map(object => (object[0] === cornerHandleIdx && object[1] === i)).indexOf(true) > -1;\n        if (isSelected && !hasClass(handle, 'selectedCorner')) {\n          addClass(handle, 'selectedCorner');\n        } else if (!isSelected && hasClass(handle, 'selectedCorner')) {\n          removeClass(handle, 'selectedCorner');\n        }\n      });  \n    }\n\n    // Resize formatter elements\n    const { x, y, width, height } = outer.getBBox();\n    setFormatterElSize(this.shape, x, y, width, height);\n  }\n\n  updateState = annotation => {\n    const shape = drawEmbeddedSVG(annotation);\n    const points = getPoints(shape);\n    this.setPoints(points);\n  }\n\n}","import Tool from '@recogito/annotorious/src/tools/Tool';\nimport RubberbandBetterMultipolygon from './RubberbandBetterMultipolygon';\nimport EditableBetterMultipolygon from './EditableBetterMultipolygon';\nimport { isTouchDevice } from '@recogito/annotorious/src/util/Touch';\n\n/**\n * A rubberband selector for Multipolygon fragments.\n */\nconst isTouch = isTouchDevice();\nexport const getPath = (points) => {\n  const round = num => Math.round(10 * num) / 10;\n  let path = \"\"\n  for (let pointList of points){\n    path += \"M\"\n    let first = true \n    for (let point of pointList){\n      if (first){\n        first = false\n        path += round(point.x).toString() + \",\" + round(point.y).toString()\n      } else {\n        path += \" L\" + round(point.x).toString() + \",\" + round(point.y).toString()\n      }\n    }\n    path += \" Z\"\n  }\n  return path\n}\nexport const toSVGTarget = (points, image) => ({\n  source: image?.src,\n  selector: {\n    type: \"SvgSelector\",\n    value: `<svg><path d=\"${getPath(points)}\" /></svg>`\n  }\n});\n\nexport default class RubberbandBetterMultipolygonTool extends Tool {\n\n  constructor(g, config, env) {\n    super(g, config, env);\n    this._isDrawing = false;\n    document.addEventListener('keydown', evt => {\n      if (evt.key == \"z\" && evt.ctrlKey) {\n        this.undo();\n      }\n      if (evt.key == 'n') {\n        this.newPart();\n      }\n    });\n    this._startOnSingleClick = false;\n  }\n  get isDrawing() {\n    return this._isDrawing;\n  }\n\n  startDrawing = (x, y, startOnSingleClick) => {\n    this._isDrawing = true;\n    if (!startOnSingleClick){\n      this._startOnSingleClick = false \n    } else {\n      this._startOnSingleClick = startOnSingleClick;\n    }\n    this.attachListeners({\n      mouseMove: this.onMouseMove,\n      mouseUp: this.onMouseUp,\n      dblClick: this.onDblClick\n    });\n    \n    this.rubberband = new RubberbandBetterMultipolygon([ x, y ], this.g, this.config, this.env);\n    this.rubberband.on('close', ({ shape, selection }) => {\n      shape.annotation = selection;\n      this.emit('complete', shape);  \n      this.stop();\n    }); \n  }\n\n  stop = () => {\n    this.detachListeners();\n    \n    this._isDrawing = false;\n\n    if (this.rubberband) {\n      this.rubberband.destroy();\n      this.rubberband = null;\n    }\n  }\n  undo = () =>{\n    if (this.rubberband){\n      this.rubberband.undo();\n\n    }\n  }\n\n  renderDebugImages = (canvasInput, src, polygons, hierarchy, div) => {\n    const dst = cv.Mat.zeros(src.rows, src.cols, cv.CV_8UC3);\n  \n    const color = new cv.Scalar(\n      Math.round(Math.random() * 255), \n      Math.round(Math.random() * 255),\n      Math.round(Math.random() * 255));\n  \n    cv.drawContours(dst, polygons, -1, color, 1, 8, hierarchy, 0);\n  \n    const mask = document.createElement('CANVAS');\n    mask.width = canvasInput.width;\n    mask.height = canvasInput.height;\n    cv.imshow(mask, src);\n  \n    div.appendChild(mask);\n  \n    const output = document.createElement('CANVAS');\n    output.width = canvasInput.width;\n    output.height = canvasInput.height;\n    cv.imshow(output, dst);\n    \n    div.appendChild(output);\n  \n    dst.delete(); \n  }\n  chunk = (array, size) => {\t\n    const chunked_arr = [];\t\n  \n    let index = 0;\t\n    while (index < array.length) {\t\n      chunked_arr.push(array.slice(index, size + index));\t\n      index += size;\t\n    }\t\n  \n    return chunked_arr;\t\n  }\n\n  findContourPolygon = (annotation) => {\n    const chunk = (array, size) => {\t\n      const chunked_arr = [];\t\n    \n      let index = 0;\t\n      while (index < array.length) {\t\n        chunked_arr.push(array.slice(index, size + index));\t\n        index += size;\t\n      }\t\n    \n      return chunked_arr;\t\n    }\n    console.log(\"blubb\", this.viewer.drawer);\n    const { canvas } = this.viewer.drawer\n    const src = cv.imread(canvas);\n    console.log(\"src\", cv.THRESH_BINARY, cv.THRESH_OTSU);\n    // Convert to grayscale & threshold\n    cv.cvtColor(src, src, cv.COLOR_RGB2GRAY, 0);\n    cv.adaptiveThreshold(src, src, 200, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY, 5, 15);// Find contours\n    const contours = new cv.MatVector();\n    const hierarchy = new cv.Mat();\n    cv.findContours(src, contours, hierarchy, cv.RETR_CCOMP, cv.CHAIN_APPROX_SIMPLE);\n    console.log(\"contours\", contours);\n    let dst = cv.Mat.zeros(src.cols, src.rows, cv.CV_8UC3);\n    for (let i = 0; i < contours.size(); ++i) {\n      let color = new cv.Scalar(Math.round(Math.random() * 255), Math.round(Math.random() * 255),\n                                Math.round(Math.random() * 255));\n      cv.drawContours(dst, contours, i, color, 1, cv.LINE_8, hierarchy, 100);\n    }\n    //cv.imshow('output', dst);\n      \n  // Approximate closed polygons, keep only the largest\n  const polygons = new cv.MatVector();\n  let allContourPoints = [];\n  let largestAreaPolygon = { area: 0 };\n  let secondLargestPolygon = { area: 0 };\n\n  for (let i = 0; i < contours.size(); ++i) {\n    const polygon = new cv.Mat();\n    const contour = contours.get(i);\n   \n    cv.approxPolyDP(contour, polygon, 0.03, true);\n    allContourPoints = allContourPoints.concat(this.chunk(polygon.data32S, 2))\n    polygons.push_back(polygon);\n\n    //  Compute contour areas\n    const area = cv.contourArea(polygon);\n\n    if (area > largestAreaPolygon.area)\n      secondLargestPolygon = largestAreaPolygon\n      largestAreaPolygon = { area, polygon };\n\n    // contour.delete(); \n    // polygon.delete();\n  }\n\n  \n  // if (debugDiv)\n    // renderDebugImages(canvasInput, src, polygons, hierarchy,debugDiv);\n  const shape = svgFragmentToShape(annotation, this.env.image);\n  console.log(\"shape\", shape);\n  let points = svgPathToPolygons(shape)\n  console.log(\"points\", points);\n  console.log(\"allContourPoints\", allContourPoints);\n  let newPoints = []\n  for (let polygon of points){\n    let newPoly = []\n    for (let point of polygon){\n      let closestPoint = {\n        dist: 5000,\n        point: null\n      }\n      for (let proposedPoint of allContourPoints){\n        var dist = Math.sqrt( Math.pow((point[0]-proposedPoint[0]), 2) + Math.pow((point[1]-proposedPoint[1]), 2) );\n        if (dist < closestPoint.dist){\n          closestPoint.dist = dist\n          closestPoint.point = proposedPoint\n        }\n      }\n      if (closestPoint.dist < 5){\n        newPoly.push(closestPoint.point)\n      } else {\n        newPoly.push(point)\n      }\n    }\n    newPoints.push(newPoly)\n  }\n  console.log(this.tools.current)\n  //this.renderDebugImages(canvas, src, polygons, hierarchy,document.getElementById(\"output\"));\n  src.delete(); \n  \n  hierarchy.delete(); \n  contours.delete(); \n  polygons.delete();\n  return allContourPoints;\n  }\n  \n  newPart = () =>{\n    if (this.rubberband){\n      this.rubberband.newPart();\n\n    }\n  }\n\n  onMouseMove = (x, y) =>\n    this.rubberband.dragTo([ x, y ]);\n\n  onMouseUp = (x, y, evt) => {\n    if (evt.altKey){\n      this.onDblClick(evt);\n    } else if (evt.ctrlKey) {\n      this.rubberband.undo();\n    } else{\n      const { width, height } = this.rubberband.getBoundingClientRect();\n\n      const minWidth = this.config.minSelectionWidth || 4;\n      const minHeight = this.config.minSelectionHeight || 4;\n      if (width >= minWidth || height >= minHeight) {\n        this.rubberband.addPoint([ x, y ]);\n      } else {\n        this.emit('cancel');\n        this.stop();\n      }\n    }\n  }\n  onScaleChanged = scale => {\n    \n    if (this.rubberband)\n      this.rubberband.onScaleChanged(scale);\n  }\n\n  onDblClick = (x, y) => {\n    this._isDrawing = false;\n\n    this.rubberband.addPoint([ x, y ]);\n\n    const shape = this.rubberband.element;\n    shape.annotation = this.rubberband.toSelection();\n    this.emit('complete', shape);\n\n    this.stop();\n  }\n\n  createEditableShape = annotation => \n    new EditableBetterMultipolygon(annotation, this.g, this.config, this.env);\n\n}\n\nRubberbandBetterMultipolygonTool.identifier = 'bettermultipolygon';\n\nRubberbandBetterMultipolygonTool.supports = annotation => {\n  const selector = annotation.selector('SvgSelector');\n  if (selector)\n    return selector.value?.match(/^<svg.*<path d=/g);\n}","import PointTool from './point/PointTool';\nimport RubberbandCircleTool from './circle/RubberbandCircleTool';\nimport RubberbandEllipseTool from './ellipse/RubberbandEllipseTool';\nimport RubberbandFreehandTool from './freehand/RubberbandFreehandTool';\nimport RubberbandMultipolygonTool from './multipolygon/RubberbandMultipolygonTool';\nimport RubberbandBetterMultipolygonTool from './betterMultipolygon/RubberbandBetterMultipolygonTool';\n\nconst ALL_TOOLS = new Set([\n  'point',\n  'circle',\n  'ellipse',\n  'freehand',\n  // 'multipolygon',\n  'bettermultipolygon'\n]);\n\nconst SelectorPack = (anno, config) => {\n\n  // Add configured tools, or all\n  const useTools = config?.tools ? \n    new Set(config.tools.map(t => t.toLowerCase())) : ALL_TOOLS;\n  console.log(\"use tools:\", useTools);\n  if (useTools.has('circle'))\n    anno.addDrawingTool(RubberbandCircleTool);\n\n  if (useTools.has('point'))\n    anno.addDrawingTool(PointTool);\n\n  if (useTools.has('ellipse'))\n    anno.addDrawingTool(RubberbandEllipseTool);\n  \n  if (useTools.has('freehand'))\n    anno.addDrawingTool(RubberbandFreehandTool);\n\n  if (useTools.has('multipolygon'))\n    anno.addDrawingTool(RubberbandMultipolygonTool);\n  if (useTools.has('bettermultipolygon'))\n  anno.addDrawingTool(RubberbandBetterMultipolygonTool);\n\n}\n\nexport default SelectorPack;\n"],"names":["root","factory","exports","module","define","amd","self","E","prototype","on","name","callback","ctx","e","this","push","fn","once","listener","off","apply","arguments","_","emit","data","slice","call","evtArr","i","len","length","evts","liveEvents","TinyEmitter","equal","a","b","constructor","keys","Array","isArray","RegExp","source","flags","valueOf","Object","toString","hasOwnProperty","key","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","definition","o","defineProperty","enumerable","get","obj","prop","getRandomValues","isTouchDevice","window","navigator","maxTouchPoints","msMaxTouchPoints","SVG_NAMESPACE","getClassNames","el","attr","getAttribute","Set","split","addClass","className","classNames","add","setAttribute","from","join","removeClass","size","removeAttribute","hasClass","has","rnds8","Uint8Array","rng","crypto","bind","msCrypto","Error","uuid","REGEX","byteToHex","substr","options","buf","offset","rnds","random","arr","toLowerCase","validate","TypeError","stringify","WebAnnotation","annotation","opts","opt_props","opt_opts","underlying","type","target","selector","find","s","other","id","equals","style","readOnly","motivation","body","bodies","state","entries","value","exact","start","end","args","stub","Selection","cloned","JSON","parse","assign","IMPLEMENTATION_MISSING","isTouch","ToolLike","g","config","env","console","log","ResizeObserver","resizeObserver","svgBounds","svg","getBoundingClientRect","viewBox","baseVal","width","height","scale","Math","max","onScaleChanged","observe","parentNode","evt","pt","createSVGPoint","bbox","x","clientX","y","clientY","left","top","matrixTransform","getScreenCTM","inverse","offsetX","offsetY","getCTM","containerGroup","document","createElementNS","group","drawCircle","r","c","radius","handleRadius","inner","outer","appendChild","handle","querySelector","parseFloat","closest","image","Element","HTMLDocument","enableResponsive","disconnect","EventEmitter","Tool","mouseMove","mouseUp","dblClick","getSVGPoint","started","addEventListener","button","removeEventListener","startOnSingleClick","startDrawing","formatters","supports","EditableShape","parseRectFragment","conformsTo","startsWith","format","includes","substring","indexOf","map","w","h","naturalWidth","naturalHeight","toFragment","fragmentUnit","px","py","pw","ph","src","toPercentRectFragment","toPixelRectFragment","toRectFragment","renderedVia","EditablePoint","scaleHandle","point","isGrabbed","setHandleXY","onMouseMove","onMouseUp","container","elementGroup","drawHandle","onGrab","removeChild","PointTool","isPoint","element","identifier","sanitize","doc","cleanEl","attributes","forEach","scripts","getElementsByTagName","reverse","querySelectorAll","svgFragmentToShape","originalDoc","namespaced","parser","DOMParser","parseFromString","isPrefixDeclared","lookupPrefix","isDefaultNamespaceSVG","lookupNamespaceURI","firstChild","XMLSerializer","serializeToString","documentElement","replace","drawEmbeddedSVG","shape","cloneNode","toSVGTarget","serialized","outerHTML","setXYR","setCircleSize","cx","cy","innerCircle","outerCircle","getCircleSize","CircleMask","imageDimensions","circle","tx","ty","mask","RubberbandCircle","anchorX","anchorY","oppositeX","oppositeY","display","anchor","pow","redraw","Mask","pointerEvents","isFirefox","test","userAgent","formatSvgEl","svgEl","reduce","merged","String","nodeType","Node","ELEMENT_NODE","elements","formatterEl","getBBox","append","appendFormatterEl","setFormatterElSize","EditableCircle","handles","topleft","topright","bottomright","bottomleft","draggedHandleIdx","anchorHandle","mousePos","getHandleXY","mouseX","mouseY","abs","idx0","idx2","idx3","idx1","grabbedElem","pos","grabbedAt","constrain","coord","setSize","handleIdx","oppositeHandle","stretchCorners","t","formatter","RubberbandCircleTool","attachListeners","rubberband","destroy","dragTo","detachListeners","minWidth","minSelectionWidth","minHeight","minSelectionHeight","toSelection","stop","match","rx","ry","setEllipseSize","innerEllipse","outerEllipse","getEllipseSize","EllipseMask","ellipse","RubberbandEllipse","drawEllipse","EditableEllipse","leftHandle","anchorLeft","RubberbandEllipseTool","RubberbandFreehand","points","str","xy","addPoint","setPoints","freehand","getPoints","pointList","trim","EditableFreehand","round","num","delta","dx","dy","updatedPoints","RubberbandFreehandTool","_isDrawing","onDblClick","toUpperCase","RubberbandMultipolygon","ps","attr2","p","head","headRest","lastCorner","pop","multipolygon","pointArray","getPointsFromPathValue","nodeValue","polygon","results","allcoords","result","index","coords","toFixed","EditableMultipolygon","first","idx","pointListIDX","found","updatedPointsIDX","newPoints","svgFragmentToPoints","RubberbandMultipolygonTool","undo","newPart","altKey","ctrlKey","RubberbandBetterMultipolygon","mousepos","closeHandle","isClosable","close","getDistanceToStart","Infinity","sqrt","pointInPolygon","x1","x2","y1","y2","is_in","EditableBetterMultipolygon","onSelectCorner","corners","thisCorner","nextCorner","drawMidpoint","selected","cornerhandlesIDX","newMidpoints","midpoints","midpointList","updatedMidpointlist","filter","object","midpointsToDelete","updatedPointlist","updatedHandles","cornerHandles","handlesList","handlesToDelete","handlesToStay","onKeyDown","midpointsIDX","grabbedElement","updatedCorners","updatedcornerListIdx","midBefore","midAfter","cornerList","updatedCornersList","updatedcornerIdx","corner","createMidpoint","cornerHandle","createCornerHandle","stopPropagation","lastMouseDown","Date","getTime","which","deleteSelected","pointlist","newPointList","cornerHandleIdx","distances","handleXY","thisXY","cornerHandleIdxUpdate","updatedPointList","onMoveShape","onMoveCornerHandle","onAddPoint","midpoint","getPath","cornerIdx","isSelected","path","RubberbandBetterMultipolygonTool","_startOnSingleClick","selection","canvasInput","polygons","hierarchy","div","dst","cv","Mat","zeros","rows","cols","CV_8UC3","color","Scalar","drawContours","createElement","imshow","output","array","chunked_arr","viewer","drawer","canvas","imread","THRESH_BINARY","THRESH_OTSU","cvtColor","COLOR_RGB2GRAY","adaptiveThreshold","ADAPTIVE_THRESH_GAUSSIAN_C","contours","MatVector","findContours","RETR_CCOMP","CHAIN_APPROX_SIMPLE","LINE_8","allContourPoints","largestAreaPolygon","area","contour","approxPolyDP","concat","chunk","data32S","push_back","contourArea","svgPathToPolygons","newPoly","closestPoint","dist","proposedPoint","tools","current","ALL_TOOLS","anno","useTools","addDrawingTool"],"sourceRoot":""}